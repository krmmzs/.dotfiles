"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A very basic parser
 *
 * @public
 */
class Parser {
    constructor(_content) {
        this._content = _content;
        this._curr = 0;
    }
    eof() {
        return this._curr >= this._content.length;
    }
    skipSpaces() {
        for (let i = this._curr; i <= this._content.length; i++) {
            let ch = this._content[i];
            if (!ch || /\S/.test(ch)) {
                this._curr = i;
                break;
            }
        }
    }
    get index() {
        return this._curr;
    }
    get curr() {
        return this._content[this._curr] || '';
    }
    get len() {
        return this._content.length;
    }
    next(count = 1) {
        return this._content.slice(this._curr + 1, this._curr + 1 + count);
    }
    nextIndex(character, checkEscape = true, allowEnd = true) {
        if (this._curr >= this.len - 1)
            return allowEnd ? this.len - 1 : -1;
        let i = this._curr + 1;
        let pre = this.curr || '';
        while (i != this.len - 1) {
            let ch = this._content[i];
            if (ch == character && (!checkEscape || pre !== '\\')) {
                break;
            }
            pre = ch;
            i = i + 1;
        }
        if (!allowEnd && i == this.len - 1 && character != this._content[i]) {
            return -1;
        }
        return i;
    }
    prev() {
        return this._content[this._curr - 1] || '';
    }
    iterate(fn) {
        while (this._curr < this._content.length) {
            let fine = fn(this.curr, this._curr);
            if (fine === false) {
                break;
            }
            this._curr = this._curr + 1;
        }
    }
    eat(count) {
        let end = this._curr + count;
        end = Math.min(end, this.len);
        let str = this._content.slice(this._curr, end);
        this._curr = end;
        return str;
    }
    // make curr to index, return contnet between curr (inclusive) and index (exclusive)
    eatTo(index) {
        if (index == this._curr)
            return '';
        let str = this._content.slice(this._curr, index);
        this._curr = index;
        return str;
    }
}
exports.default = Parser;
