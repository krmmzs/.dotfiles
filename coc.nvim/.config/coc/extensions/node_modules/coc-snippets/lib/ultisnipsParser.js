"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const readline_1 = __importDefault(require("readline"));
const types_1 = require("./types");
const util_1 = require("./util");
function fixFiletype(filetype) {
    if (filetype === 'javascript_react')
        return 'javascriptreact';
    return filetype;
}
class UltiSnipsParser {
    constructor(channel, trace = false) {
        this.channel = channel;
        this.trace = trace;
    }
    parseUltisnipsFile(filetype, filepath) {
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let pycodes = [];
        let snippets = [];
        let block;
        let preLines = [];
        let first;
        let priority = 0;
        let lnum = 0;
        let clearsnippets = null;
        let parsedContext = null;
        let extendFiletypes = [];
        rl.on('line', line => {
            lnum += 1;
            if (!block && (line.startsWith('#') || line.length == 0))
                return;
            const [head, tail] = util_1.headTail(line);
            if (!block) {
                switch (head) {
                    case 'priority':
                        let n = parseInt(tail.trim(), 10);
                        if (!isNaN(n))
                            priority = n;
                        break;
                    case 'extends':
                        let fts = tail.trim().split(/,\s+/);
                        for (let ft of fts) {
                            ft = fixFiletype(ft);
                            if (extendFiletypes.indexOf(ft) == -1) {
                                extendFiletypes.push(ft);
                            }
                        }
                        break;
                    case 'clearsnippets':
                        clearsnippets = priority;
                        break;
                    case 'context':
                        parsedContext = tail.replace(/^"(.+)"$/, '$1');
                        break;
                    case 'snippet':
                    case 'global':
                        block = head;
                        first = tail;
                        break;
                }
                return;
            }
            if (head == 'endglobal' && block == 'global') {
                block = null;
                pycodes.push(...preLines);
                preLines = [];
                return;
            }
            if (head == 'endsnippet' && block == 'snippet') {
                block = null;
                try {
                    let body = preLines.join('\n');
                    let ms = first.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?\s*$/);
                    let trigger = util_1.getTriggerText(ms[1]);
                    let option = ms[4] || '';
                    let regex = null;
                    let originRegex;
                    if (option.indexOf('r') !== -1) {
                        originRegex = trigger;
                        let pattern = util_1.convertRegex(trigger);
                        regex = new RegExp(pattern.endsWith('$') ? pattern : pattern + '$');
                        // get the real text
                        trigger = util_1.getRegexText(trigger);
                        option = option + 'i';
                    }
                    let snippet = {
                        originRegex,
                        context: parsedContext ? parsedContext : (option.includes('e') ? ms[3] : undefined),
                        filepath,
                        filetype,
                        prefix: trigger,
                        autoTrigger: option.indexOf('A') !== -1,
                        lnum: lnum - preLines.length - 2,
                        triggerKind: getTriggerKind(option),
                        description: ms[2] || '',
                        regex,
                        body,
                        priority
                    };
                    this.debug(`Loaded snippet: ${JSON.stringify(snippet, null, 2)}`);
                    snippets.push(snippet);
                }
                catch (e) {
                    this.error(`Create snippet error on: ${filepath}:${lnum - preLines.length - 1} ${e.message}`);
                }
                finally {
                    parsedContext = null;
                    preLines = [];
                }
            }
            if (block == 'snippet' || block == 'global') {
                preLines.push(line);
                return;
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                resolve({ snippets, clearsnippets, pythonCode: pycodes.join('\n'), extendFiletypes });
            });
        });
    }
    error(str) {
        if (!this.channel)
            return;
        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] ${str}`);
    }
    debug(str) {
        if (!this.channel || !this.trace)
            return;
        this.channel.appendLine(`[Debug ${(new Date()).toLocaleTimeString()}] ${str}`);
    }
}
exports.default = UltiSnipsParser;
function decode(str) {
    return str.replace(/\\`/g, '`').replace(/\\{/g, '{');
}
function getTriggerKind(option) {
    if (option.indexOf('i') !== -1) {
        return types_1.TriggerKind.InWord;
    }
    if (option.indexOf('w') !== -1) {
        return types_1.TriggerKind.WordBoundary;
    }
    if (option.indexOf('b') !== -1) {
        return types_1.TriggerKind.LineBegin;
    }
    return types_1.TriggerKind.SpaceBefore;
}
