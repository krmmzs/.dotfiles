"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextmateProvider = void 0;
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const jsonc_parser_1 = require("jsonc-parser");
const path_1 = __importDefault(require("path"));
const baseProvider_1 = __importDefault(require("./baseProvider"));
const types_1 = require("./types");
const util_1 = require("./util");
class TextmateProvider extends baseProvider_1.default {
    constructor(channel, config, subscriptions) {
        super(config, channel);
        this.config = config;
        this.subscriptions = subscriptions;
        this.loadedFiles = new Set();
        this.loadedSnippets = [];
        this.loadedLanguageIds = new Set();
        this.definitions = new Map();
    }
    async init() {
        if (this.config.loadFromExtensions) {
            for (let extension of coc_nvim_1.extensions.all) {
                await this.loadSnippetDefinition(extension);
            }
            coc_nvim_1.extensions.onDidLoadExtension(extension => {
                this.loadSnippetDefinition(extension).then(items => {
                    if (items === null || items === void 0 ? void 0 : items.length) {
                        items = items.filter(o => o.languageIds.some(id => coc_nvim_1.workspace.languageIds.has(id)));
                        this.loadSnippetsFromDefinition(extension.id, items);
                    }
                }, e => {
                    this.error(`Error on load textmate snippets: ${e.message}`, e.stack);
                });
            }, null, this.subscriptions);
            coc_nvim_1.extensions.onDidUnloadExtension(id => {
                this.loadedSnippets = this.loadedSnippets.filter(item => {
                    return item.extensionId !== id;
                });
            }, null, this.subscriptions);
        }
        let paths = this.config.snippetsRoots;
        for (let dir of paths !== null && paths !== void 0 ? paths : []) {
            await this.loadDefinitionFromRoot(dir);
        }
        for (let languageId of coc_nvim_1.workspace.languageIds) {
            await this.loadByLanguageId(languageId);
        }
        coc_nvim_1.workspace.onDidOpenTextDocument(e => {
            this.loadByLanguageId(e.languageId);
        }, null, this.subscriptions);
        if (this.config.projectSnippets) {
            coc_nvim_1.workspace.workspaceFolders.forEach(folder => {
                let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                void this.loadFromWorkspace(fsPath);
            });
            coc_nvim_1.workspace.onDidChangeWorkspaceFolders(e => {
                e.removed.forEach(folder => {
                    let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                    this.loadedSnippets = this.loadedSnippets.filter(o => {
                        return !o.filepath.startsWith(fsPath + path_1.default.sep);
                    });
                });
                e.added.forEach(folder => {
                    let fsPath = coc_nvim_1.Uri.parse(folder.uri).fsPath;
                    void this.loadFromWorkspace(fsPath);
                });
            });
        }
    }
    async loadFromWorkspace(fsPath) {
        let root = path_1.default.join(fsPath, '.vscode');
        await this.loadDefinitionFromRoot(root);
    }
    async loadByLanguageId(languageId) {
        if (this.loadedLanguageIds.has(languageId))
            return;
        let filetypes = this.getFiletypes(languageId);
        this.info(`Load textmate snippets from filetypes: ${filetypes.join(', ')}`);
        for (let languageId of filetypes) {
            if (this.loadedLanguageIds.has(languageId))
                continue;
            this.loadedLanguageIds.add(languageId);
            for (let [extensionId, items] of this.definitions.entries()) {
                for (let item of items) {
                    if (!item.languageIds.includes(languageId))
                        continue;
                    await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
                }
            }
        }
    }
    async getSnippetFiles(filetype) {
        let filetypes = this.getFiletypes(filetype);
        let filepaths = [];
        for (let filetype of filetypes) {
            let snippets = this.loadedSnippets.filter(s => s.filetype == filetype);
            if (snippets.length) {
                for (let snip of snippets) {
                    let { filepath } = snip;
                    if (filepaths.indexOf(filepath) == -1) {
                        filepaths.push(filepath);
                    }
                }
            }
        }
        return util_1.distinct(filepaths);
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        var _a;
        if (autoTrigger)
            return [];
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        let snippets = await this.getSnippets(document.filetype);
        if (!snippets || !snippets.length)
            return [];
        let edits = [];
        for (let snip of snippets) {
            let { prefix } = snip;
            if (!line.endsWith(prefix))
                continue;
            let pre = line.slice(0, line.length - prefix.length);
            // not allowed after word
            if (pre.length && /\w/.test(pre[pre.length - 1]))
                continue;
            edits.push({
                prefix,
                range: coc_nvim_1.Range.create(position.line, position.character - prefix.length, position.line, position.character),
                newText: snip.body,
                location: snip.filepath,
                description: snip.description,
                priority: (_a = snip.priority) !== null && _a !== void 0 ? _a : -1
            });
        }
        return edits;
    }
    async getSnippets(filetype) {
        let res = [];
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('all');
        let added = new Set();
        for (let filetype of filetypes) {
            let snippets = this.loadedSnippets.filter(o => o.filetype == filetype);
            if (snippets && snippets.length) {
                for (let snip of snippets) {
                    if (!added.has(snip.prefix)) {
                        added.add(snip.prefix);
                        res.push(snip);
                    }
                }
            }
        }
        return res;
    }
    async loadSnippetDefinition(extension) {
        let { packageJSON } = extension;
        const arr = [];
        if (packageJSON.contributes && packageJSON.contributes.snippets) {
            let { snippets } = packageJSON.contributes;
            const extensionId = extension.id;
            for (let item of snippets) {
                let p = path_1.default.join(extension.extensionPath, item.path);
                if (fs_1.default.existsSync(p)) {
                    let languages = typeof item.language == 'string' ? [item.language] : item.language;
                    arr.push({
                        languageIds: languages,
                        filepath: p
                    });
                }
            }
            if (snippets && snippets.length) {
                this.definitions.set(extensionId, arr);
            }
        }
        return arr;
    }
    async loadDefinitionFromRoot(root) {
        root = coc_nvim_1.workspace.expand(root);
        if (!fs_1.default.existsSync(root))
            return;
        let files = await fs_1.default.promises.readdir(root, 'utf8');
        files = files.filter(f => f.endsWith('.json') || f.endsWith('.code-snippets'));
        let items = [];
        for (let file of files) {
            let filepath = path_1.default.join(root, file);
            if (file.endsWith('.code-snippets')) {
                let extensionId = path_1.default.basename(root);
                // Don't know languageId, load all of them
                await this.loadSnippetsFromFile(filepath, undefined, extensionId);
            }
            else {
                let basename = path_1.default.basename(file, '.json');
                items.push({ languageIds: [basename], filepath });
            }
        }
        this.definitions.set('user-snippets', items);
    }
    async loadSnippetsFromDefinition(extensionId, items) {
        for (let item of items) {
            if (!fs_1.default.existsSync(item.filepath))
                continue;
            await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
        }
    }
    async loadSnippetsFromFile(snippetFilePath, languageIds, extensionId) {
        if (this.isLoaded(snippetFilePath))
            return;
        if (this.isIgnored(snippetFilePath))
            return;
        let contents;
        try {
            contents = await fs_1.default.promises.readFile(snippetFilePath, 'utf8');
        }
        catch (e) {
            this.error(`Error on readFile "${snippetFilePath}": ${e.message}`);
            return;
        }
        this.loadSnippetsFromText(snippetFilePath, extensionId, languageIds, contents);
    }
    isLoaded(filepath) {
        for (let file of this.loadedFiles) {
            if (util_1.sameFile(file, filepath)) {
                return true;
            }
        }
        return false;
    }
    loadSnippetsFromText(filepath, extensionId, ids, contents) {
        let snippets = [];
        let defaulLanguageId;
        try {
            let errors = [];
            let lines = contents.split(/\r?\n/);
            defaulLanguageId = util_1.languageIdFromComments(lines);
            let snippetObject = jsonc_parser_1.parse(contents, errors, { allowTrailingComma: true });
            if (errors.length)
                this.error(`Parse error of ${filepath}`, errors);
            if (snippetObject) {
                for (let key of Object.keys(snippetObject)) {
                    let p = '"' + key + '"';
                    let idx = lines.findIndex(line => line.trim().startsWith(p));
                    let lnum = idx == -1 ? 0 : idx;
                    snippets.push(Object.assign({ lnum }, snippetObject[key]));
                }
            }
        }
        catch (ex) {
            this.error(`Error on parse "${filepath}": ${ex.message}`, ex.stack);
            snippets = [];
        }
        this.loadedFiles.add(filepath);
        const normalizedSnippets = [];
        snippets.forEach((snip) => {
            if (!snip.prefix)
                return;
            let languageIds = snip.scope ? snip.scope.split(',') : undefined;
            if (!languageIds && defaulLanguageId)
                languageIds = [defaulLanguageId];
            if (!languageIds && ids)
                languageIds = ids;
            if (!languageIds)
                languageIds = ['all'];
            let prefixs = Array.isArray(snip.prefix) ? snip.prefix : [snip.prefix];
            prefixs.forEach(prefix => {
                for (let filetype of languageIds) {
                    normalizedSnippets.push({
                        extensionId,
                        filepath,
                        lnum: snip.lnum,
                        filetype,
                        body: typeof snip.body === 'string' ? snip.body : snip.body.join('\n'),
                        prefix,
                        description: typeof snip.description === 'string' ? snip.description : typeof snip.description !== 'undefined' ? snip.description.join('\n') : '',
                        triggerKind: types_1.TriggerKind.WordBoundary,
                        priority: -1
                    });
                }
            });
        });
        this.loadedSnippets.push(...normalizedSnippets);
        this.info(`Loaded ${normalizedSnippets.length} textmate snippets from ${filepath}`);
        this.trace('Loaded snippets:', normalizedSnippets);
    }
}
exports.TextmateProvider = TextmateProvider;
