"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderManager = void 0;
const coc_nvim_1 = require("coc.nvim");
const path_1 = __importDefault(require("path"));
const types_1 = require("./types");
const util_1 = require("./util");
class ProviderManager {
    constructor(channel, subscriptions) {
        this.channel = channel;
        this.providers = new Map();
        subscriptions.push(coc_nvim_1.Disposable.create(() => {
            this.providers.clear();
        }));
    }
    regist(provider, name) {
        this.providers.set(name, provider);
        return coc_nvim_1.Disposable.create(() => {
            this.providers.delete(name);
        });
    }
    get hasProvider() {
        return this.providers.size > 0;
    }
    async init() {
        let providers = Array.from(this.providers.values());
        await Promise.all(providers.map(provider => {
            return provider.init();
        })).catch(e => {
            coc_nvim_1.workspace.nvim.echoError(e);
            this.appendError('init', e);
        });
    }
    async getSnippets(filetype) {
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            try {
                let snippets = await provider.getSnippets(filetype);
                snippets.map(s => s.provider = name);
                list.push(...snippets);
            }
            catch (e) {
                this.appendError(`getSnippets of ${name}`, e);
            }
        }
        list.sort((a, b) => {
            if (a.filetype != b.filetype && (a.filetype == filetype || b.filetype == filetype)) {
                return a.filetype == filetype ? -1 : 1;
            }
            if (a.priority != b.priority) {
                return b.priority - a.priority;
            }
            if (a.filepath != b.filepath) {
                return b.filepath > a.filepath ? 1 : -1;
            }
            return a.lnum - b.lnum;
        });
        return list;
    }
    async getSnippetFiles(filetype) {
        let files = [];
        for (let [name, provider] of this.providers.entries()) {
            try {
                let res = await provider.getSnippetFiles(filetype);
                files = files.concat(res);
            }
            catch (e) {
                this.appendError(`getSnippetFiles of ${name}`, e);
            }
        }
        return files;
    }
    async getTriggerSnippets(bufnr, autoTrigger = false) {
        let doc = coc_nvim_1.workspace.getDocument(bufnr);
        if (!doc)
            return [];
        let position = await coc_nvim_1.window.getCursorPosition();
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            try {
                let items = await provider.getTriggerSnippets(doc, position, autoTrigger);
                for (let item of items) {
                    list.push(Object.assign({ source: name }, item));
                }
            }
            catch (e) {
                this.appendError(`get trigger snippets of ${name}`, e);
            }
        }
        list.sort((a, b) => b.priority - a.priority);
        if (list.length > 1) {
            let priority = list[0].priority;
            list = list.filter(o => o.priority == priority);
        }
        return list;
    }
    appendError(name, e) {
        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] Error on ${name}: ${typeof e === 'string' ? e : e.message}`);
        if (e instanceof Error) {
            this.channel.appendLine(e.stack);
        }
    }
    async provideCompletionItems(document, position, _token, context) {
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        if (!doc)
            return [];
        let snippets = await this.getSnippets(doc.filetype);
        let currline = doc.getline(position.line, true);
        let { input, col } = context.option;
        let character = util_1.characterIndex(currline, col);
        let before_content = currline.slice(0, character);
        let res = [];
        let contextPrefixes = [];
        for (let snip of snippets) {
            let contentBehind = before_content;
            if (contextPrefixes.indexOf(snip.prefix) !== -1)
                continue;
            if (snip.regex != null && snip.prefix == '')
                continue;
            if (snip.context) {
                let provider = this.providers.get(snip.provider);
                let valid;
                try {
                    valid = await provider.checkContext(snip.context);
                }
                catch (e) {
                    this.appendError(`checkContext of ${snip.provider}`, e);
                    valid = false;
                }
                if (!valid)
                    continue;
                contextPrefixes.push(snip.prefix);
            }
            let head = this.getPrefixHead(doc, snip.prefix);
            if (input.length == 0 && !before_content.endsWith(snip.prefix))
                continue;
            let ultisnip = snip.provider == 'ultisnips' || snip.provider == 'snipmate';
            let item = {
                label: snip.prefix,
                kind: coc_nvim_1.CompletionItemKind.Snippet,
                filterText: snip.prefix,
                detail: snip.description,
                insertTextFormat: coc_nvim_1.InsertTextFormat.Snippet
            };
            item.data = {
                snip,
                provider: snip.provider,
                filepath: `${path_1.default.basename(snip.filepath)}:${snip.lnum}`
            };
            if (ultisnip) {
                item.data.ultisnip = {
                    context: snip.context,
                    regex: snip.originRegex
                };
            }
            if (snip.regex) {
                if (!input.length || snip.prefix && input[0] != snip.prefix[0])
                    continue;
                let content = before_content + snip.prefix;
                let ms = content.match(snip.regex);
                if (!ms)
                    continue;
            }
            else if (head && before_content.endsWith(head)) {
                contentBehind = before_content.slice(0, -head.length);
                Object.assign(item, {
                    textEdit: {
                        range: coc_nvim_1.Range.create({ line: position.line, character: character - head.length }, position),
                        newText: snip.prefix
                    }
                });
            }
            else if (input.length == 0) {
                let { prefix } = snip;
                contentBehind = before_content.slice(0, -prefix.length);
                Object.assign(item, {
                    preselect: true,
                    textEdit: {
                        range: coc_nvim_1.Range.create({ line: position.line, character: character - prefix.length }, position),
                        newText: snip.prefix
                    }
                });
            }
            if (snip.triggerKind == types_1.TriggerKind.LineBegin && contentBehind.trim().length)
                continue;
            if (snip.triggerKind == types_1.TriggerKind.SpaceBefore) {
                if (contentBehind.length && !/\s/.test(contentBehind[contentBehind.length - 1])) {
                    continue;
                }
            }
            if (!item.textEdit) {
                item.textEdit = {
                    range: coc_nvim_1.Range.create({ line: position.line, character }, position),
                    newText: snip.prefix
                };
            }
            res.push(item);
        }
        return res;
    }
    async resolveCompletionItem(item) {
        let provider = this.providers.get(item.data.provider);
        if (provider) {
            let doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
            let filetype = doc ? doc.filetype : undefined;
            let insertSnippet = item.data.snip.body;
            if (coc_nvim_1.snippetManager && insertSnippet) {
                if (typeof provider.resolveSnippetBody === 'function') {
                    insertSnippet = await Promise.resolve(provider.resolveSnippetBody(insertSnippet));
                }
                item.textEdit.newText = insertSnippet;
                let resolved = await coc_nvim_1.snippetManager.resolveSnippet(insertSnippet, item.data.ultisnip);
                if (typeof resolved !== 'string') {
                    coc_nvim_1.window.showErrorMessage(`Please upgrade your coc.nvim to use coc-snippets`);
                    return;
                }
                let ms = filetype === null || filetype === void 0 ? void 0 : filetype.match(/^\w+/);
                let block = util_1.markdownBlock(resolved, ms == null ? 'txt' : ms[0]);
                item.documentation = {
                    kind: 'markdown',
                    value: block + (item.data.filepath ? `\n${item.data.filepath}` : '')
                };
            }
        }
        return item;
    }
    getPrefixHead(doc, prefix) {
        let res = 0;
        for (let idx = prefix.length - 1; idx >= 0; idx--) {
            if (!doc.isWord(prefix[idx])) {
                res = idx;
                break;
            }
        }
        return res == 0 ? '' : prefix.slice(0, res + 1);
    }
}
exports.ProviderManager = ProviderManager;
