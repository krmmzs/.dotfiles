"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnipmateProvider = void 0;
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const baseProvider_1 = __importDefault(require("./baseProvider"));
const parser_1 = __importDefault(require("./parser"));
const types_1 = require("./types");
const util_1 = require("./util");
class SnipmateProvider extends baseProvider_1.default {
    constructor(channel, config, subscriptions) {
        super(config, channel);
        this.config = config;
        this.subscriptions = subscriptions;
        this.fileItems = [];
        this.snippetFiles = [];
        coc_nvim_1.workspace.onDidSaveTextDocument(async (doc) => {
            let uri = coc_nvim_1.Uri.parse(doc.uri);
            if (uri.scheme != 'file')
                return;
            let filepath = uri.fsPath;
            if (!fs_1.default.existsSync(filepath))
                return;
            let idx = this.snippetFiles.findIndex(s => util_1.sameFile(s.filepath, filepath));
            if (idx !== -1) {
                let filetype = this.snippetFiles[idx].filetype;
                this.snippetFiles.splice(idx, 1);
                await this.loadSnippetsFromFile(filetype, filepath);
            }
        }, null, this.subscriptions);
    }
    async init() {
        let { nvim } = coc_nvim_1.workspace;
        let author = await nvim.getVar('snips_author');
        if (!author)
            await nvim.setVar('snips_author', this.config.author);
        this.fileItems = await this.loadAllSnippetFiles();
        coc_nvim_1.workspace.onDidRuntimePathChange(async (e) => {
            for (let rtp of e) {
                let items = await this.getSnippetFileItems(path_1.default.join(rtp, 'snippets'));
                if (items === null || items === void 0 ? void 0 : items.length) {
                    this.fileItems.push(...items);
                    for (let item of items) {
                        if (coc_nvim_1.workspace.filetypes.has(item.filetype)) {
                            await this.loadSnippetsFromFile(item.filetype, item.filepath);
                        }
                    }
                }
            }
        }, null, this.subscriptions);
        for (let filetype of coc_nvim_1.workspace.filetypes) {
            await this.loadByFiletype(filetype);
        }
        coc_nvim_1.workspace.onDidOpenTextDocument(async (e) => {
            let doc = coc_nvim_1.workspace.getDocument(e.bufnr);
            await this.loadByFiletype(doc.filetype);
        }, null, this.subscriptions);
    }
    async loadByFiletype(filetype) {
        let filetypes = filetype ? this.getFiletypes(filetype) : [];
        filetypes.push('_');
        for (let item of this.fileItems) {
            if (!filetypes.includes(item.filetype))
                continue;
            await this.loadSnippetsFromFile(item.filetype, item.filepath);
        }
    }
    async loadSnippetsFromFile(filetype, filepath) {
        let idx = this.snippetFiles.findIndex(o => util_1.sameFile(o.filepath, filepath));
        if (idx !== -1)
            return;
        idx = this.fileItems.findIndex(o => o.filepath == filepath);
        if (idx !== -1)
            this.fileItems.splice(idx, 1);
        if (this.isIgnored(filepath))
            return;
        let res = await this.parseSnippetsFile(filetype, filepath);
        this.snippetFiles.push({ filepath, filetype, snippets: res.snippets });
        this.info(`Loaded ${res.snippets.length} ${filetype} snipmate snippets from: ${filepath}`);
        if (res.extends.length) {
            let fts = res.extends;
            let curr = this.config.extends[filetype] || [];
            for (let ft of fts) {
                await this.loadByFiletype(ft);
                if (!curr.includes(ft)) {
                    curr.push(ft);
                }
            }
            this.config.extends[filetype] = curr;
        }
    }
    /**
     * Resolve snippet body to inserted text.
     *
     * @public
     * @param {Snippet} snippet
     * @param {Range} _range
     * @param {string} _line
     * @returns {Promise<string>}
     */
    async resolveSnippetBody(body) {
        let parser = new parser_1.default(body);
        let resolved = '';
        let { nvim } = coc_nvim_1.workspace;
        while (!parser.eof()) {
            if (parser.curr == '`') {
                let idx = parser.nextIndex('`', true, false);
                if (idx == -1) {
                    resolved = resolved + parser.eatTo(parser.len);
                    break;
                }
                let code = parser.eatTo(idx + 1);
                code = code.slice(1, -1);
                if (code.startsWith('Filename')) {
                    resolved = resolved + await nvim.call('expand', '%:p:t');
                }
                else if (!code.startsWith('!')) {
                    resolved = '`!v ' + code + '`';
                }
                else {
                    resolved = '`' + code + '`';
                }
                continue;
            }
            parser.iterate(ch => {
                if (ch == '`') {
                    return false;
                }
                else {
                    resolved = resolved + ch;
                }
                return true;
            });
        }
        return resolved;
    }
    /**
     * Parse snippets from snippets file.
     */
    parseSnippetsFile(filetype, filepath) {
        let res = [];
        let extendsFiletypes = [];
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let lnum = 0;
        let lines = [];
        let prefix = '';
        let description = '';
        rl.on('line', line => {
            lnum += 1;
            if (line.startsWith('#'))
                return;
            if (/^extends\s/.test(line)) {
                let ft = line.replace(/^extends\s+/, '');
                if (ft)
                    extendsFiletypes.push(ft);
                return;
            }
            if (line.startsWith('snippet')) {
                line = line.replace(/\s*$/, '');
                if (lines.length && prefix) {
                    res.push({
                        filepath,
                        filetype,
                        lnum: lnum - lines.length - 1,
                        body: lines.join('\n').replace(/\s+$/, ''),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.SpaceBefore,
                        provider: 'snipmate'
                    });
                    lines = [];
                }
                let ms = line.match(/^snippet\s+(\S+)(?:\s(.+))?$/);
                if (!ms) {
                    prefix = '';
                    this.error(`Broken line on ${filepath}:${lnum}`);
                    return;
                }
                prefix = ms[1];
                description = ms[2] || '';
                return;
            }
            if (prefix) {
                if (line.startsWith('\t')) {
                    lines.push(line.slice(1));
                }
                else {
                    lines.push(line);
                }
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                if (lines.length) {
                    res.push({
                        filepath,
                        lnum: lnum - lines.length - 1,
                        filetype,
                        body: lines.join('\n'),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.SpaceBefore
                    });
                }
                this.trace('snipmate snippets', res);
                resolve({ snippets: res, extends: extendsFiletypes });
            });
        });
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        if (autoTrigger)
            return [];
        let snippets = await this.getSnippets(document.filetype);
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        if (!line || line[line.length - 1] == ' ')
            return [];
        snippets = snippets.filter(s => {
            let { prefix } = s;
            if (!line.endsWith(prefix))
                return false;
            let pre = line.slice(0, line.length - prefix.length);
            return pre.length == 0 || /\s/.test(pre[pre.length - 1]);
        });
        let edits = [];
        for (let s of snippets) {
            let character = position.character - s.prefix.length;
            let range = coc_nvim_1.Range.create(position.line, character, position.line, position.character);
            let newText = await this.resolveSnippetBody(s.body);
            edits.push({
                prefix: s.prefix,
                description: s.description,
                location: s.filepath,
                range,
                newText,
                priority: -1
            });
        }
        return edits;
    }
    async getSnippetFiles(filetype) {
        let filetypes = filetype ? this.getFiletypes(filetype) : [];
        filetypes.push('_');
        let res = [];
        for (let s of this.snippetFiles) {
            if (filetypes.indexOf(s.filetype) !== -1) {
                res.push(s.filepath);
            }
        }
        return res;
    }
    async getSnippets(filetype) {
        let filetypes = this.getFiletypes(filetype);
        let snippetFiles = this.snippetFiles.filter(o => o.filetype == '_' || filetypes.indexOf(o.filetype) !== -1);
        let result = [];
        snippetFiles.sort((a, b) => {
            if (a.filetype == b.filetype)
                return 1;
            if (a.filetype == filetype)
                return -1;
            return 1;
        });
        for (let file of snippetFiles) {
            let { snippets } = file;
            for (let snip of snippets) {
                result.push(snip);
            }
        }
        return result;
    }
    async loadAllSnippetFiles() {
        let { env } = coc_nvim_1.workspace;
        let rtps = env.runtimepath.split(',');
        let res = [];
        for (let rtp of rtps) {
            let items = await this.getSnippetFileItems(path_1.default.join(rtp, 'snippets'));
            res.push(...items);
        }
        return res;
    }
    async getSnippetFileItems(directory) {
        let res = [];
        let stat = await util_1.statAsync(directory);
        if (stat && stat.isDirectory()) {
            let files = await util_1.readdirAsync(directory);
            if (files.length) {
                for (let f of files) {
                    let file = path_1.default.join(directory, f);
                    if (file.endsWith('.snippets')) {
                        let basename = path_1.default.basename(f, '.snippets');
                        let filetype = basename.split('-', 2)[0];
                        res.push({ filepath: file, directory, filetype });
                    }
                    else {
                        let stat = await util_1.statAsync(file);
                        if (stat && stat.isDirectory()) {
                            let files = await util_1.readdirAsync(file);
                            for (let filename of files) {
                                if (filename.endsWith('.snippets')) {
                                    res.push({ filepath: path_1.default.join(file, filename), directory, filetype: f });
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
}
exports.SnipmateProvider = SnipmateProvider;
