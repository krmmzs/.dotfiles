"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const util_1 = require("./util");
const codesMap = new Map();
codesMap.set(1, 'invalid snippet line, trigger requried.');
codesMap.set(2, 'invalid snippet option, option "$1" not supported.');
codesMap.set(3, 'invalid python expression, $1');
codesMap.set(4, 'invalid code interpolation, #! not supported.');
const validOptions = ['b', 'i', 'w', 'r', 'e', 'A'];
class LanguageProvider {
    constructor(channel, trace = 'error') {
        this.channel = channel;
        this.trace = trace;
        this.disposables = [];
        this.collection = coc_nvim_1.languages.createDiagnosticCollection('snippets');
        for (let doc of coc_nvim_1.workspace.documents) {
            if (this.shouldValidate(doc.uri)) {
                this.validate(doc.uri, doc.getDocumentContent()).catch(e => {
                    channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}]: ${e.message}`);
                });
            }
        }
        coc_nvim_1.workspace.onDidOpenTextDocument(async (textDocument) => {
            let doc = coc_nvim_1.workspace.getDocument(textDocument.uri);
            if (!this.shouldValidate(doc.uri))
                return;
            await this.validate(doc.uri, doc.getDocumentContent());
        }, null, this.disposables);
        coc_nvim_1.workspace.onDidChangeTextDocument(async (ev) => {
            let doc = coc_nvim_1.workspace.getDocument(ev.textDocument.uri);
            if (!doc || !this.shouldValidate(doc.uri))
                return;
            await this.validate(doc.uri, doc.getDocumentContent());
        }, null, this.disposables);
        coc_nvim_1.workspace.onDidCloseTextDocument(e => {
            this.collection.delete(e.uri);
        }, null, this.disposables);
    }
    shouldValidate(uri) {
        return uri.endsWith('.snippets');
    }
    async validate(uri, content) {
        let lines = content.split('\n');
        let diagnostics = [];
        let curr = 0;
        for (let line of lines) {
            if (/^snippet\s*$/.test(line)) {
                let range = coc_nvim_1.Range.create(curr, 0, curr, line.length);
                diagnostics.push(coc_nvim_1.Diagnostic.create(range, codesMap.get(1), coc_nvim_1.DiagnosticSeverity.Error, 1));
                continue;
            }
            if (line.startsWith('snippet ')) {
                let content = util_1.headTail(line)[1];
                let ms = content.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?$/);
                let prefix = ms[1];
                if (prefix.length > 2 && prefix[0] == prefix[prefix.length - 1] && !/\w/.test(prefix[0])) {
                    prefix = prefix.slice(1, prefix.length - 1);
                }
                let option = ms[4] || '';
                let isExpression = option.indexOf('r') !== -1;
                let startCharacter = line.length - option.length;
                for (let ch of option) {
                    if (validOptions.indexOf(ch) == -1) {
                        let range = coc_nvim_1.Range.create(curr, startCharacter, curr, startCharacter + 1);
                        let message = codesMap.get(2).replace('$1', ch);
                        diagnostics.push(coc_nvim_1.Diagnostic.create(range, message, coc_nvim_1.DiagnosticSeverity.Error, 2));
                    }
                    startCharacter = startCharacter + 1;
                }
                if (isExpression) {
                    try {
                        util_1.convertRegex(prefix);
                    }
                    catch (e) {
                        let start = line.indexOf(prefix);
                        let range = coc_nvim_1.Range.create(curr, start, curr, start + prefix.length);
                        let message = codesMap.get(3).replace('$1', e.message);
                        diagnostics.push(coc_nvim_1.Diagnostic.create(range, message, coc_nvim_1.DiagnosticSeverity.Error, 3));
                    }
                }
            }
            else {
                let idx = line.indexOf('`#!');
                if (idx !== -1) {
                    let range = coc_nvim_1.Range.create(curr, idx, curr, idx + 3);
                    let message = codesMap.get(4);
                    diagnostics.push(coc_nvim_1.Diagnostic.create(range, message, coc_nvim_1.DiagnosticSeverity.Error, 4));
                }
            }
            curr++;
        }
        if (this.trace == 'verbose') {
            this.channel.appendLine(`[Debug ${(new Date()).toLocaleTimeString()}] diagnostics of ${uri} -> ${JSON.stringify(diagnostics)}`);
        }
        this.collection.set(uri, diagnostics);
    }
    provideCompletionItems(_document, position, _token, context) {
        let { input, col } = context.option;
        if (context.triggerCharacter == '$') {
            return [{
                    label: '$VISUAL',
                    kind: coc_nvim_1.CompletionItemKind.Snippet,
                    // tslint:disable-next-line: no-invalid-template-strings
                    detail: '${VISUAL}',
                    insertTextFormat: coc_nvim_1.InsertTextFormat.Snippet,
                    textEdit: {
                        range: coc_nvim_1.Range.create(position.line, position.character - 1, position.line, position.character),
                        // tslint:disable-next-line: no-invalid-template-strings
                        newText: '\\${VISUAL${1::default}\\}'
                    }
                }];
        }
        if (col == 0 && 'snippet'.startsWith(input)) {
            return [{
                    label: 'snippet',
                    kind: coc_nvim_1.CompletionItemKind.Snippet,
                    detail: 'Snippet definition',
                    insertTextFormat: coc_nvim_1.InsertTextFormat.Snippet,
                    // tslint:disable-next-line: no-invalid-template-strings
                    insertText: 'snippet ${1:Tab_trigger} "${2:Description}" ${3:b}\n$0\nendsnippet'
                }];
        }
        return [];
    }
    async resolveCompletionItem(item) {
        // tslint:disable-next-line: deprecation
        let text = item.insertText || item.textEdit.newText;
        // tslint:disable-next-line: deprecation
        let snip = await Promise.resolve(coc_nvim_1.snippetManager.resolveSnippet(text, true));
        item.documentation = {
            kind: 'markdown',
            value: util_1.markdownBlock(snip.toString(), 'snippets')
        };
        return item;
    }
}
exports.default = LanguageProvider;
