"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UltiSnippetsProvider = void 0;
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const baseProvider_1 = __importDefault(require("./baseProvider"));
const types_1 = require("./types");
const ultisnipsParser_1 = __importDefault(require("./ultisnipsParser"));
const util_1 = require("./util");
const pythonCodes = new Map();
class UltiSnippetsProvider extends baseProvider_1.default {
    constructor(channel, config, context) {
        super(config, channel);
        this.config = config;
        this.context = context;
        this.snippetFiles = [];
        this.fileItems = [];
        coc_nvim_1.workspace.onDidSaveTextDocument(async (doc) => {
            let uri = coc_nvim_1.Uri.parse(doc.uri);
            if (uri.scheme != 'file' || !doc.uri.endsWith('.snippets'))
                return;
            let filepath = uri.fsPath;
            if (!fs_1.default.existsSync(filepath))
                return;
            let idx = this.snippetFiles.findIndex(s => util_1.sameFile(s.filepath, filepath));
            if (idx !== -1) {
                const snippetFile = this.snippetFiles[idx];
                this.snippetFiles.splice(idx, 1);
                await this.loadSnippetsFromFile({ filetype: snippetFile.filetype, filepath, directory: snippetFile.directory });
            }
            else {
                // TODO filetype could be wrong
                let filetype = filetypeFromBasename(path_1.default.basename(filepath, '.snippets'));
                await this.loadSnippetsFromFile({ filetype, filepath, directory: path_1.default.dirname(filepath) });
            }
        }, null, this.context.subscriptions);
    }
    get directories() {
        let dirs = this.config.directories || [];
        return dirs.map(dir => coc_nvim_1.workspace.expand(dir));
    }
    async init() {
        let { nvim, env } = coc_nvim_1.workspace;
        this.info(`Using ultisnips directories:`, this.directories);
        try {
            await nvim.call('pyxeval', ['1']);
        }
        catch (e) {
            throw new Error(`Error on execute :pyx command, ultisnips feature of coc-snippets requires pyx support on vim.`);
        }
        this.parser = new ultisnipsParser_1.default(this.channel, this.config.trace);
        this.fileItems = await this.loadAllFilItems(env.runtimepath);
        coc_nvim_1.workspace.onDidRuntimePathChange(async (e) => {
            let subFolders = await this.getSubFolders();
            const newItems = [];
            for (const dir of e) {
                let res = await this.getFilesFromDirectory(dir, subFolders);
                if (res === null || res === void 0 ? void 0 : res.length)
                    newItems.push(...res);
            }
            if (newItems.length) {
                this.fileItems.push(...newItems);
                const items = this.getValidItems(newItems);
                if (items.length)
                    await this.loadFromItems(items);
            }
        }, null, this.context.subscriptions);
        let filepath = this.context.asAbsolutePath('python/ultisnips.py');
        await coc_nvim_1.workspace.nvim.command(`exe 'pyxfile '.fnameescape('${filepath}')`);
        const items = this.getValidItems(this.fileItems);
        if (items.length)
            await this.loadFromItems(items);
        coc_nvim_1.workspace.onDidOpenTextDocument(async (e) => {
            let doc = coc_nvim_1.workspace.getDocument(e.bufnr);
            if (doc)
                await this.loadByFiletype(doc.filetype);
        }, null, this.context.subscriptions);
    }
    async loadByFiletype(filetype) {
        let items = this.getFileItems(filetype);
        if (items.length)
            await this.loadFromItems(items);
    }
    getFileItems(filetype) {
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('all');
        return this.fileItems.filter(o => filetypes.includes(o.filetype));
    }
    get allFiletypes() {
        let filetypes = Array.from(coc_nvim_1.workspace.filetypes);
        let res = [];
        for (let ft of filetypes) {
            let arr = this.getFiletypes(ft);
            arr.forEach(val => {
                if (!res.includes(val))
                    res.push(val);
            });
        }
        res.push('all');
        return res;
    }
    // valid items for current filetypes
    getValidItems(fileItems) {
        let filetypes = this.allFiletypes;
        return fileItems.filter(o => filetypes.includes(o.filetype));
    }
    async loadFromItems(items) {
        if (items.length) {
            await Promise.all(items.map(item => {
                return this.loadSnippetsFromFile(item);
            }));
            let pythonCode = '';
            for (let [file, code] of pythonCodes.entries()) {
                if (code)
                    pythonCode += `# ${file}\n` + code + '\n';
            }
            if (pythonCode) {
                pythonCodes.clear();
                await this.executePythonCode(pythonCode);
            }
        }
    }
    async loadSnippetsFromFile(fileItem) {
        let { filepath, directory, filetype } = fileItem;
        let idx = this.snippetFiles.findIndex(o => util_1.sameFile(o.filepath, filepath));
        if (idx !== -1)
            return;
        if (this.isIgnored(filepath))
            return;
        idx = this.fileItems.findIndex(o => o.filepath == filepath);
        if (idx !== -1)
            this.fileItems.splice(idx, 1);
        let { snippets, pythonCode, extendFiletypes, clearsnippets } = await this.parser.parseUltisnipsFile(filetype, filepath);
        this.snippetFiles.push({
            extendFiletypes,
            clearsnippets,
            directory,
            filepath,
            filetype,
            snippets
        });
        if (extendFiletypes === null || extendFiletypes === void 0 ? void 0 : extendFiletypes.length) {
            let filetypes = this.config.extends[filetype] || [];
            filetypes = filetypes.concat(extendFiletypes);
            this.config.extends[filetype] = util_1.distinct(filetypes);
            let fts = [];
            for (let ft of extendFiletypes) {
                let filetypes = this.getFiletypes(ft);
                filetypes.forEach(s => {
                    if (!fts.includes(s))
                        fts.push(s);
                });
            }
            let items = this.fileItems.filter(o => fts.includes(o.filetype));
            await Promise.all(items.map(item => {
                return this.loadSnippetsFromFile(item);
            }));
        }
        this.info(`Loaded ${snippets.length} UltiSnip snippets from: ${filepath}`);
        if (pythonCode)
            pythonCodes.set(filepath, pythonCode);
    }
    async checkContext(context) {
        let pyCodes = [
            'import re, os, vim, string, random',
            'if "snip" in globals():',
            '  __snip = snip',
            'snip = ContextSnippet()',
            `context = ${context}`,
            'if "__snip" in globals():',
            '  snip = __snip',
        ];
        await this.executePyCodes(pyCodes);
        return await coc_nvim_1.workspace.nvim.call(`pyxeval`, 'True if context else False');
    }
    async executePyCodes(lines) {
        try {
            await coc_nvim_1.workspace.nvim.command(`pyx ${addPythonTryCatch(lines.join('\n'))}`);
        }
        catch (e) {
            let err = new Error(e.message);
            err.stack = `Error on execute python code:\n${lines}\n` + e.stack;
            throw err;
        }
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        let snippets = await this.getSnippets(document.filetype);
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        if (!line || line[line.length - 1] == ' ')
            return [];
        snippets = snippets.filter(s => {
            let { prefix, regex } = s;
            if (autoTrigger && !s.autoTrigger)
                return false;
            if (regex) {
                let ms = line.match(regex);
                if (!ms)
                    return false;
                prefix = ms[0];
            }
            if (!line.endsWith(prefix))
                return false;
            if (s.triggerKind == types_1.TriggerKind.InWord)
                return true;
            let pre = line.slice(0, line.length - prefix.length);
            if (s.triggerKind == types_1.TriggerKind.LineBegin)
                return pre.trim() == '';
            if (s.triggerKind == types_1.TriggerKind.SpaceBefore)
                return pre.length == 0 || /\s/.test(pre[pre.length - 1]);
            if (s.triggerKind == types_1.TriggerKind.WordBoundary)
                return pre.length == 0 || !document.isWord(pre[pre.length - 1]);
            return false;
        });
        snippets.sort((a, b) => {
            if (a.context && !b.context)
                return -1;
            if (b.context && !a.context)
                return 1;
            return 0;
        });
        let edits = [];
        let contextPrefixes = [];
        for (let s of snippets) {
            let character;
            if (s.context) {
                let valid = await this.checkContext(s.context);
                if (!valid)
                    continue;
                contextPrefixes.push(s.context);
            }
            else if (contextPrefixes.indexOf(s.prefix) !== -1) {
                continue;
            }
            if (s.regex == null) {
                character = position.character - s.prefix.length;
            }
            else {
                let len = line.match(s.regex)[0].length;
                character = position.character - len;
            }
            let range = coc_nvim_1.Range.create(position.line, character, position.line, position.character);
            edits.push({
                range,
                newText: s.body,
                prefix: s.prefix,
                description: s.description,
                location: s.filepath,
                priority: s.priority,
                regex: s.originRegex,
                context: s.context,
            });
            if (s.context)
                break;
        }
        return edits;
    }
    async getSnippetFiles(filetype) {
        let filetypes = this.getFiletypes(filetype);
        let res = [];
        for (let s of this.snippetFiles) {
            if (filetypes.includes(s.filetype)) {
                res.push(s.filepath);
            }
        }
        return res;
    }
    async getSnippets(filetype) {
        let filetypes = this.getFiletypes(filetype);
        filetypes.push('all');
        let snippetFiles = this.snippetFiles.filter(o => filetypes.indexOf(o.filetype) !== -1);
        let min = null;
        let result = [];
        snippetFiles.sort((a, b) => {
            if (a.filetype == b.filetype)
                return 1;
            if (a.filetype == filetype)
                return -1;
            return 1;
        });
        for (let file of snippetFiles) {
            let { snippets, clearsnippets } = file;
            if (typeof clearsnippets == 'number') {
                min = min ? Math.max(min, clearsnippets) : clearsnippets;
            }
            for (let snip of snippets) {
                if (snip.regex || snip.context) {
                    result.push(snip);
                }
                else {
                    let idx = result.findIndex(o => o.prefix == snip.prefix && o.triggerKind == snip.triggerKind);
                    if (idx == -1) {
                        result.push(snip);
                    }
                    else {
                        let item = result[idx];
                        if (snip.priority > item.priority) {
                            result[idx] = item;
                        }
                    }
                }
            }
        }
        if (min != null)
            result = result.filter(o => o.priority >= min);
        result.sort((a, b) => {
            if (a.context && !b.context)
                return -1;
            if (b.context && !a.context)
                return 1;
            return 0;
        });
        return result;
    }
    async loadAllFilItems(runtimepath) {
        let { directories } = this;
        let res = [];
        for (let directory of directories) {
            if (path_1.default.isAbsolute(directory)) {
                let items = await this.getSnippetFileItems(directory);
                res.push(...items);
            }
        }
        let subFolders = await this.getSubFolders();
        let rtps = runtimepath.split(',');
        for (let rtp of rtps) {
            let items = await this.getFilesFromDirectory(rtp, subFolders);
            res.push(...items);
        }
        return res;
    }
    async getSubFolders() {
        let { directories } = this;
        directories = directories.filter(s => !path_1.default.isAbsolute(s));
        // use UltiSnipsSnippetDirectories
        let dirs = await coc_nvim_1.workspace.nvim.eval('get(g:, "UltiSnipsSnippetDirectories", [])');
        for (let dir of dirs) {
            if (directories.indexOf(dir) == -1) {
                directories.push(dir);
            }
        }
        return directories;
    }
    async getFilesFromDirectory(directory, subFolders) {
        let res = [];
        for (let folder of subFolders) {
            let items = await this.getSnippetFileItems(path_1.default.join(directory, folder));
            res.push(...items);
        }
        return res;
    }
    /**
     * Get files in directory.
     */
    async getSnippetFileItems(directory) {
        let res = [];
        let stat = await util_1.statAsync(directory);
        if (stat && stat.isDirectory()) {
            let files = await util_1.readdirAsync(directory);
            if (files.length) {
                for (let f of files) {
                    let file = path_1.default.join(directory, f);
                    if (file.endsWith('.snippets')) {
                        let basename = path_1.default.basename(f, '.snippets');
                        let filetype = filetypeFromBasename(basename);
                        res.push({ filepath: file, directory, filetype });
                    }
                    else {
                        let stat = await util_1.statAsync(file);
                        if (stat && stat.isDirectory()) {
                            let files = await util_1.readdirAsync(file);
                            for (let filename of files) {
                                if (filename.endsWith('.snippets')) {
                                    res.push({ filepath: path_1.default.join(file, filename), directory, filetype: f });
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
    async executePythonCode(pythonCode) {
        try {
            let dir = path_1.default.join(os_1.default.tmpdir(), `coc.nvim-${process.pid}`);
            if (!fs_1.default.existsSync(dir))
                fs_1.default.mkdirSync(dir);
            let tmpfile = path_1.default.join(os_1.default.tmpdir(), `coc.nvim-${process.pid}`, `coc-ultisnips-${util_1.uid()}.py`);
            let code = addPythonTryCatch(pythonCode);
            fs_1.default.writeFileSync(tmpfile, '# -*- coding: utf-8 -*-\n' + code, 'utf8');
            this.info(`Execute python code in: ${tmpfile}`);
            await coc_nvim_1.workspace.nvim.command(`exe 'pyxfile '.fnameescape('${tmpfile}')`);
        }
        catch (e) {
            this.error(`Error on execute python script ${e.stack}:`, pythonCode);
            coc_nvim_1.window.showMessage(`Error on execute python script: ${e.message}`, 'error');
        }
    }
}
exports.UltiSnippetsProvider = UltiSnippetsProvider;
function filetypeFromBasename(basename) {
    if (basename == 'typescript_react')
        return 'typescriptreact';
    if (basename == 'javascript_react')
        return 'javascriptreact';
    if (basename.includes('_'))
        return basename.split('_', 2)[0];
    return basename.split('-', 2)[0];
}
/**
  * vim8 doesn't throw any python error with :py command
  * we have to use g:errmsg since v:errmsg can't be changed in python script.
  */
function addPythonTryCatch(code) {
    if (!coc_nvim_1.workspace.isVim)
        return code;
    let lines = [
        'import traceback, vim',
        `vim.vars['errmsg'] = ''`,
        'try:',
    ];
    lines.push(...code.split('\n').map(line => '    ' + line));
    lines.push('except Exception as e:');
    lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
    return lines.join('\n');
}
