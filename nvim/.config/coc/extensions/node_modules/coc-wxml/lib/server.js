(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const server_1 = __webpack_require__(3);
const connectionFromOptions_1 = __importDefault(__webpack_require__(50));
const argv = process.argv.slice(2);
if (argv.indexOf('-h') !== -1) {
    process.stdout.write(`
    wxml Language Service Command-Line Interface.

    Usage: wxml [args]

    -h --help         show this help
    --stdio           Use stdio to communicate with the server, default behaviour
    --node-ipc        Use node-ipc to communicate with the server. Useful for calling from a node.js client
    --socket [port]   Use a socket (with a port number like --socket 5051) to communicate with the server
  `);
    process.exit();
}
const options = {};
const methods = ['node-ipc', 'stdio', 'socket'];
const method = argv.find(m => methods.indexOf(m.slice(2)) !== -1);
options.method = method ? method.slice(2) : 'stdio';
if (options.method === 'socket') {
    let idx = argv.findIndex(m => m == '--socket');
    options.port = argv[idx + 1];
    cliInvariant(options.port, '--socket option requires port.');
}
const connection = connectionFromOptions_1.default(options);
if (connection) {
    console.log = connection.console.log.bind(connection.console);
    console.error = connection.console.error.bind(connection.console);
    server_1.createServer(connection).listen();
}
function cliInvariant(condition, ...msgs) {
    if (!condition) {
        /* eslint-disable no-console */
        console.error('ERROR:', ...msgs);
        /* eslint-enable */
        process.exit(1);
    }
}
process.on('uncaughtException', e => console.error('uncaughtException:' + e.message));
process.on('unhandledRejection', e => console.error('unhandledRejection:' + e.message));


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const vscode_languageserver_1 = __webpack_require__(4);
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const manager_1 = __webpack_require__(39);
function createServer(connection) {
    const documents = new vscode_languageserver_1.TextDocuments();
    const manager = manager_1.getManager();
    let shouldShutdown = false;
    connection.onShutdown(() => {
        shouldShutdown = true;
    });
    process.on('exit', code => {
        if (code !== 0) {
            connection.sendNotification('window/showMessage', {
                type: vscode_languageserver_protocol_1.MessageType.Error,
                message: `wxml language server abnormal exit with code ${code}`
            });
        }
    });
    connection.onExit(() => {
        connection.sendNotification('window/showMessage', {
            type: vscode_languageserver_protocol_1.MessageType.Info,
            message: 'wxml service exited'
        });
        if (shouldShutdown) {
            process.exit();
        }
        else {
            process.exit(1);
        }
    });
    connection.onInitialize((params) => {
        let snippetSupport = false;
        const initializationOptions = params.initializationOptions;
        if (initializationOptions) {
            const { textDocument } = params.capabilities;
            if (textDocument
                && textDocument.completion
                && textDocument.completion.completionItem
                && textDocument.completion.completionItem.snippetSupport) {
                snippetSupport = true;
            }
        }
        manager.setConfig({
            complete: {
                completeEvent: true,
                useSnippet: snippetSupport
            }
        });
        documents.onDidClose(e => {
            manager.removeDocument(e.document.uri);
        });
        const capabilities = {
            // Tell the client that the server works in FULL text document sync mode
            textDocumentSync: documents.syncKind,
            completionProvider: {
                triggerCharacters: ['<'],
                resolveProvider: false,
            },
            hoverProvider: true,
        };
        return { capabilities };
    });
    // The settings have changed. Is send on server activation as well.
    connection.onDidChangeConfiguration((change) => {
        let config = change.settings;
        manager.setConfig(config.wxml);
    });
    const pendingValidationRequests = {};
    const validationDelayMs = 100;
    documents.onDidOpen((change) => {
        triggerValidation(change.document);
    });
    // When the text document first opened or when its content has changed.
    documents.onDidChangeContent((change) => {
        triggerValidation(change.document);
    });
    // A document has closed: clear all diagnostics
    documents.onDidClose((event) => {
        cleanPendingValidation(event.document);
        connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
    });
    function cleanPendingValidation(textDocument) {
        const request = pendingValidationRequests[textDocument.uri];
        if (request) {
            clearTimeout(request);
            delete pendingValidationRequests[textDocument.uri];
        }
    }
    function triggerValidation(textDocument) {
        cleanPendingValidation(textDocument);
        pendingValidationRequests[textDocument.uri] = setTimeout(() => {
            delete pendingValidationRequests[textDocument.uri];
            validateTextDocument(textDocument);
        }, validationDelayMs);
    }
    function validateTextDocument(textDocument) {
        const diagnostics = manager.doDiagnostic(textDocument);
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
    }
    connection.onCompletion(textDocumentPosition => {
        const document = documents.get(textDocumentPosition.textDocument.uri);
        if (!document)
            return null;
        return manager.doComplete(document, textDocumentPosition.position);
    });
    connection.onCompletionResolve(item => {
        return item;
    });
    connection.onHover(textDocumentPosition => {
        const document = documents.get(textDocumentPosition.textDocument.uri);
        if (!document)
            return null;
        return manager.doHover(document, textDocumentPosition.position);
    });
    return {
        listen() {
            documents.listen(connection);
            connection.listen();
        }
    };
}
exports.createServer = createServer;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="./thenable.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(5);
exports.Event = vscode_languageserver_protocol_1.Event;
const configuration_1 = __webpack_require__(30);
const workspaceFolders_1 = __webpack_require__(32);
const Is = __webpack_require__(31);
const UUID = __webpack_require__(33);
// ------------- Reexport the API surface of the language worker API ----------------------
__export(__webpack_require__(5));
const fm = __webpack_require__(34);
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModule = fm.resolveModule;
    Files.resolveModule2 = fm.resolveModule2;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        process.exit(shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
function null2Undefined(value) {
    if (value === null) {
        return void 0;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor() {
        this._documents = Object.create(null);
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * Returns the [TextDocumentSyncKind](#TextDocumentSyncKind) used by
     * this text document manager.
     */
    get syncKind() {
        return vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not mananged by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        function isUpdateableDocument(value) {
            return Is.func(value.update);
        }
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = vscode_languageserver_protocol_1.TextDocument.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            let last = changes.length > 0 ? changes[changes.length - 1] : undefined;
            if (last) {
                let document = this._documents[td.uri];
                if (document && isUpdateableDocument(document)) {
                    if (td.version === null || td.version === void 0) {
                        throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
                    }
                    document.update(last, td.version);
                    this._onDidChangeContent.fire(Object.freeze({ document }));
                }
            }
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class ConnectionLogger {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this._connection);
        }
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Unregistering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this._connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this._connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let strategy;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (vscode_languageserver_protocol_1.ConnectionStrategy.is(arg1)) {
        strategy = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        strategy = arg3;
    }
    return _createConnection(input, output, strategy, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, strategy, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new vscode_languageserver_protocol_1.IPCMessageReader(process);
                output = new vscode_languageserver_protocol_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = vscode_languageserver_protocol_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = vscode_languageserver_protocol_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
    if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
    }
    if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            process.exit(shutdownReceived ? 0 : 1);
        });
    }
    const logger = (factories && factories.console ? new (factories.console(ConnectionLogger))() : new ConnectionLogger());
    const connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, strategy);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace];
    function asThenable(value) {
        if (Is.thenable(value)) {
            return value;
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, handler),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, handler),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, handler),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, handler),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, handler),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, handler),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, handler),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, handler),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, handler),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, handler),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, handler),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, handler),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, handler),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, handler),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, handler),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, handler),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, handler),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, handler),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, handler),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, handler),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, handler),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, handler),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, handler),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, handler),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token);
            return asThenable(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (shutdownReceived) {
                process.exit(0);
            }
            else {
                process.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
// Export the protocol currently in proposed state.
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features',
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
__export(__webpack_require__(20));
__export(__webpack_require__(21));
function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="./thenable.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(7);
const messages_1 = __webpack_require__(8);
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(9);
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(11);
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(10);
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(12);
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(13);
__export(__webpack_require__(14));
__export(__webpack_require__(19));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    ;
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            console.log("inspect");
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const is = __webpack_require__(7);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(10);
const Is = __webpack_require__(7);
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't recevied the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
Emitter._noop = function () { };
exports.Emitter = Emitter;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(10);
const Is = __webpack_require__(7);
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(10);
const Is = __webpack_require__(7);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this._emitter = undefined;
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        this.cancel();
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __webpack_require__(15);
const os_1 = __webpack_require__(16);
const crypto_1 = __webpack_require__(17);
const net_1 = __webpack_require__(18);
const messageReader_1 = __webpack_require__(9);
const messageWriter_1 = __webpack_require__(11);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __webpack_require__(18);
const messageReader_1 = __webpack_require__(9);
const messageWriter_1 = __webpack_require__(11);
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationLink", function() { return LocationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorInformation", function() { return ColorInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPresentation", function() { return ColorPresentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRangeKind", function() { return FoldingRangeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FoldingRange", function() { return FoldingRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticRelatedInformation", function() { return DiagnosticRelatedInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiagnosticSeverity", function() { return DiagnosticSeverity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Diagnostic", function() { return Diagnostic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return Command; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEdit", function() { return TextEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentEdit", function() { return TextDocumentEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CreateFile", function() { return CreateFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenameFile", function() { return RenameFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeleteFile", function() { return DeleteFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceEdit", function() { return WorkspaceEdit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WorkspaceChange", function() { return WorkspaceChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentIdentifier", function() { return TextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VersionedTextDocumentIdentifier", function() { return VersionedTextDocumentIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentItem", function() { return TextDocumentItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupKind", function() { return MarkupKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkupContent", function() { return MarkupContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItemKind", function() { return CompletionItemKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InsertTextFormat", function() { return InsertTextFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionItem", function() { return CompletionItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompletionList", function() { return CompletionList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkedString", function() { return MarkedString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hover", function() { return Hover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterInformation", function() { return ParameterInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignatureInformation", function() { return SignatureInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlightKind", function() { return DocumentHighlightKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentHighlight", function() { return DocumentHighlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolKind", function() { return SymbolKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolInformation", function() { return SymbolInformation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentSymbol", function() { return DocumentSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionKind", function() { return CodeActionKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeActionContext", function() { return CodeActionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeAction", function() { return CodeAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeLens", function() { return CodeLens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormattingOptions", function() { return FormattingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DocumentLink", function() { return DocumentLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EOL", function() { return EOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocument", function() { return TextDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextDocumentSaveReason", function() { return TextDocumentSaveReason; });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.red)
            && Is.number(candidate.green)
            && Is.number(candidate.blue)
            && Is.number(candidate.alpha);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange.prototype.deleteFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange.prototype.checkDocumentChanges = function () {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
    ;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
/**
 * Represents programming constructs like variables, classes, interfaces etc.
 * that appear in a document. Document symbols can be hierarchical and they
 * have two ranges: one that encloses its definition and one that points to
 * its most interesting range, e.g. the range of an identifier.
 */
var DocumentSymbol = /** @class */ (function () {
    function DocumentSymbol() {
    }
    return DocumentSymbol;
}());

(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void null) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === void 0 || Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || Command.is(candidate.command)) &&
            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data))
            result.data = data;
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.
 */
var DocumentLink = /** @class */ (function () {
    function DocumentLink() {
    }
    return DocumentLink;
}());

/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
var EOL = ['\n', '\r\n', '\r'];
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = null;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = null;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === null) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const Is = __webpack_require__(22);
const vscode_jsonrpc_1 = __webpack_require__(6);
const protocol_implementation_1 = __webpack_require__(23);
exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
const protocol_typeDefinition_1 = __webpack_require__(24);
exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
const protocol_workspaceFolders_1 = __webpack_require__(25);
exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
const protocol_configuration_1 = __webpack_require__(26);
exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
const protocol_colorProvider_1 = __webpack_require__(27);
exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
const protocol_foldingRange_1 = __webpack_require__(28);
exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
const protocol_declaration_1 = __webpack_require__(29);
exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        let candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling startegy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guaruntee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new vscode_jsonrpc_1.RequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new vscode_jsonrpc_1.NotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new vscode_jsonrpc_1.RequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new vscode_jsonrpc_1.NotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
//---- Configuration notification ----
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new vscode_jsonrpc_1.RequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new vscode_jsonrpc_1.NotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didOpen');
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didChange');
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didClose');
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didSave');
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/willSave');
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/willSaveWaitUntil');
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
//---- File eventing ----
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
//---- Diagnostic notification ----
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/completion');
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.type = new vscode_jsonrpc_1.RequestType('completionItem/resolve');
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
//---- Hover Support -------------------------------
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/hover');
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/signatureHelp');
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
//---- Goto Definition -------------------------------------
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/definition');
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/references');
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
//---- Document Highlight ----------------------------------
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentHighlight');
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
//---- Document Symbol Provider ---------------------------
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentSymbol');
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
//---- Workspace Symbol Provider ---------------------------
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.type = new vscode_jsonrpc_1.RequestType('workspace/symbol');
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeAction');
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeLens');
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.type = new vscode_jsonrpc_1.RequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/formatting');
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rangeFormatting');
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/onTypeFormatting');
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rename');
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/prepareRename');
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentLink');
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.type = new vscode_jsonrpc_1.RequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new vscode_jsonrpc_1.RequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new vscode_jsonrpc_1.RequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/implementation');
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/typeDefinition');
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new vscode_jsonrpc_1.RequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new vscode_jsonrpc_1.RequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentColor');
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/foldingRange');
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/declaration');
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const Is = __webpack_require__(31);
exports.ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = __webpack_require__(5);
exports.WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", { value: true });
const url = __webpack_require__(35);
const path = __webpack_require__(15);
const fs = __webpack_require__(36);
const child_process_1 = __webpack_require__(37);
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolveModule(workspaceRoot, moduleName) {
    let nodePathKey = 'NODE_PATH';
    return new Promise((resolve, reject) => {
        let nodePath = [];
        if (workspaceRoot) {
            nodePath.push(path.join(workspaceRoot, 'node_modules'));
        }
        child_process_1.exec('npm config get prefix', (error, stdout, _stderr) => {
            if (!error) {
                let globalPath = stdout.replace(/[\s\r\n]+$/, '');
                if (globalPath.length > 0) {
                    if (isWindows()) {
                        nodePath.push(path.join(globalPath, 'node_modules'));
                    }
                    else {
                        nodePath.push(path.join(globalPath, 'lib', 'node_modules'));
                    }
                }
            }
            let separator = isWindows() ? ';' : ':';
            let env = process.env;
            let newEnv = Object.create(null);
            Object.keys(env).forEach(key => newEnv[key] = env[key]);
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath.join(separator) + separator + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath.join(separator);
            }
            newEnv['ELECTRON_RUN_AS_NODE'] = '1';
            try {
                let cp = child_process_1.fork(path.join(__dirname, 'resolve.js'), [], { env: newEnv, execArgv: [] });
                if (cp.pid === void 0) {
                    reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                    return;
                }
                cp.on('message', (message) => {
                    if (message.command === 'resolve') {
                        let toRequire = moduleName;
                        if (message.success) {
                            toRequire = message.result;
                        }
                        cp.send({ command: 'exit' });
                        try {
                            resolve(__webpack_require__(38)(toRequire));
                        }
                        catch (error) {
                            reject(error);
                        }
                    }
                });
                let message = {
                    command: 'resolve',
                    args: moduleName
                };
                cp.send(message);
            }
            catch (error) {
                reject(error);
            }
        });
    });
}
exports.resolveModule = resolveModule;
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) == 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
/**
 * Resolves the given module relative to the given workspace root. In contrast to
 * `resolveModule` this method considers the parent chain as well.
 */
function resolveModule2(workspaceRoot, moduleName, nodePath, tracer) {
    return resolveModulePath(workspaceRoot, moduleName, nodePath, tracer).then((path) => {
        if (tracer) {
            tracer(`Module ${moduleName} got resolved to ${path}`);
        }
        return __webpack_require__(38)(path);
    });
}
exports.resolveModule2 = resolveModule2;

/* WEBPACK VAR INJECTION */}.call(this, "/index.js"))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 38;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getManager = void 0;
const wxmlParser_1 = __webpack_require__(40);
const wxmlDiagnostic_1 = __importDefault(__webpack_require__(46));
const wxmlComplete_1 = __importDefault(__webpack_require__(47));
const wxmlHover_1 = __importDefault(__webpack_require__(49));
let cache = {};
function getManager() {
    let config = {
        complete: {
            useSnippet: false,
            completeEvent: true
        }
    };
    return {
        setConfig(obj) {
            config = Object.assign(config, obj);
        },
        getWxmlDocument(document) {
            let { uri } = document;
            let doc = cache[uri];
            if (doc)
                return doc;
            return this.parse(document);
        },
        parse(document) {
            let { uri } = document;
            let doc = wxmlParser_1.parse(document.getText());
            cache[uri] = doc;
            return doc;
        },
        removeDocument(uri) {
            delete cache[uri];
        },
        doDiagnostic(document) {
            let doc = this.parse(document);
            return wxmlDiagnostic_1.default(document, doc);
        },
        doHover(document, position) {
            let doc = this.getWxmlDocument(document);
            return wxmlHover_1.default(document, position, doc);
        },
        doComplete(document, position) {
            let doc = this.getWxmlDocument(document);
            return wxmlComplete_1.default(document, position, doc, config.complete);
        }
    };
}
exports.getManager = getManager;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.Node = void 0;
const wxmlScanner_1 = __webpack_require__(41);
const arrays_1 = __webpack_require__(43);
const wxmlTags_1 = __webpack_require__(44);
const wxmlLanguageTypes_1 = __webpack_require__(42);
function isValidTagName(tag) {
    return /^[a-z]([a-z]|\d|-|_)*$/.test(tag);
}
function isValidAttribute(attr) {
    return /^[a-zA-Z](:|\.|-|_|\w)*$/.test(attr);
}
class Node {
    constructor(start, end, children, parent) {
        this.start = start;
        this.end = end;
        this.children = children;
        this.parent = parent;
        this.closed = false;
        this.textContents = [];
    }
    get attributeNames() {
        return this.attributes ? Object.keys(this.attributes).map(s => s.replace(/\|\d+$/, '')) : [];
    }
    isSameTag(tagInLowerCase) {
        if (!this.tag || !tagInLowerCase) {
            return false;
        }
        return (this.tag.length === tagInLowerCase.length &&
            this.tag.toLowerCase() === tagInLowerCase);
    }
    getAttributeAtOffset(offset) {
        if (!this.attributes)
            return null;
        for (let attr of Object.keys(this.attributes)) {
            let parts = attr.split('|');
            if (parts.length < 2)
                continue;
            let start = parseInt(parts[1], 10);
            let end = start + parts[0].length;
            if (offset >= start && offset <= end) {
                return attr;
            }
        }
        return null;
    }
    getAttributeOffsets(name) {
        if (!this.attributes)
            return [];
        let res = [];
        for (let attr of Object.keys(this.attributes)) {
            let parts = attr.split('|');
            if (parts[0] == name) {
                res.push(parseInt(parts[1], 10));
            }
        }
        return res;
    }
    getDuplicatedAttrs() {
        let names = this.attributeNames;
        let res = [];
        for (let name of names) {
            if (res.indexOf(name) === -1 && names.indexOf(name) !== names.lastIndexOf(name)) {
                res.push(name);
            }
        }
        return res;
    }
    getValueOffset(attributeName) {
        if (!this.attributes)
            return null;
        for (let attr of Object.keys(this.attributes)) {
            let parts = attr.split('|');
            if (attributeName === parts[0]) {
                let value = this.attributes[attr];
                if (value || value == '') {
                    return parseInt(parts[1], 10) + attributeName.length + 2;
                }
            }
        }
        return null;
    }
    getAttributeValue(attributeName) {
        if (!this.attributes)
            return null;
        for (let attr of Object.keys(this.attributes)) {
            let parts = attr.split('|');
            if (attributeName === parts[0]) {
                let value = this.attributes[attr];
                return value;
            }
        }
        return null;
    }
    get isEmpty() {
        return this.children.length === 0 && this.textContents.length === 0;
    }
    get firstChild() {
        return this.children[0];
    }
    get lastChild() {
        return this.children.length
            ? this.children[this.children.length - 1]
            : void 0;
    }
    findNodeBefore(offset) {
        let idx = arrays_1.findFirst(this.children, c => offset <= c.start) - 1;
        if (idx >= 0) {
            let child = this.children[idx];
            if (offset > child.start) {
                if (offset < child.end) {
                    return child.findNodeBefore(offset);
                }
                let lastChild = child.lastChild;
                if (lastChild && lastChild.end === child.end) {
                    return child.findNodeBefore(offset);
                }
                return child;
            }
        }
        return this;
    }
    findNodeAt(offset) {
        let idx = arrays_1.findFirst(this.children, c => offset <= c.start) - 1;
        if (idx >= 0) {
            let child = this.children[idx];
            if (offset > child.start && offset <= child.end) {
                return child.findNodeAt(offset);
            }
        }
        return this;
    }
}
exports.Node = Node;
function parse(text) {
    let scanner = wxmlScanner_1.createScanner(text);
    let wxmlDocument = new Node(0, text.length, [], void 0);
    let curr = wxmlDocument;
    let endTagStart = -1;
    let pendingAttribute = null;
    let token = scanner.scan();
    let errors = [];
    let tagStack = [];
    let currOffset = -1;
    while (token !== wxmlLanguageTypes_1.TokenType.EOS) {
        let errorMsg = scanner.getTokenError();
        if (errorMsg) {
            errors.push({
                message: errorMsg,
                offsetStart: scanner.getTokenOffset(),
                offeetEnd: scanner.getTokenEnd()
            });
        }
        // let text = scanner.getTokenType()
        // console.log(text)
        switch (token) {
            case wxmlLanguageTypes_1.TokenType.StartTagOpen:
                let child = new Node(scanner.getTokenOffset(), text.length, [], curr);
                curr.children.push(child);
                curr = child;
                break;
            case wxmlLanguageTypes_1.TokenType.StartTag:
                curr.tag = scanner.getTokenText();
                tagStack.push(`${curr.tag}|${scanner.getTokenOffset()}|${scanner.getTokenEnd()}`);
                if (!isValidTagName(curr.tag)) {
                    errors.push({
                        message: `Only [a-z] _ - allowed for tag name`,
                        offsetStart: scanner.getTokenOffset(),
                        offeetEnd: scanner.getTokenEnd()
                    });
                }
                break;
            case wxmlLanguageTypes_1.TokenType.StartTagClose:
                curr.end = scanner.getTokenEnd(); // might be later set to end tag position
                if (curr.tag && wxmlTags_1.isEmptyElement(curr.tag) && curr.parent) {
                    curr.closed = true;
                    curr = curr.parent;
                }
                break;
            case wxmlLanguageTypes_1.TokenType.EndTagOpen:
                endTagStart = scanner.getTokenOffset();
                break;
            case wxmlLanguageTypes_1.TokenType.EndTag:
                let closeTag = scanner.getTokenText().toLowerCase();
                while (!curr.isSameTag(closeTag) && curr.parent) {
                    curr.end = endTagStart;
                    curr.closed = false;
                    curr = curr.parent;
                }
                if (curr !== wxmlDocument) {
                    curr.closed = true;
                    curr.endTagStart = endTagStart;
                }
                let last = tagStack.pop();
                if (!last) {
                    errors.push({
                        message: `Start tag not found for <${closeTag}>`,
                        offsetStart: scanner.getTokenOffset(),
                        offeetEnd: scanner.getTokenEnd()
                    });
                }
                else {
                    let parts = last.toLowerCase().split('|');
                    if (closeTag !== parts[0]) {
                        errors.push({
                            message: `Close tag not found for <${parts[0]}>`,
                            offsetStart: parseInt(parts[1], 10),
                            offeetEnd: parseInt(parts[2], 10),
                        });
                    }
                }
                break;
            case wxmlLanguageTypes_1.TokenType.StartTagSelfClose:
                if (curr.parent) {
                    curr.closed = true;
                    curr.end = scanner.getTokenEnd();
                    curr = curr.parent;
                }
                tagStack.pop();
                break;
            case wxmlLanguageTypes_1.TokenType.EndTagClose:
                if (curr.parent) {
                    curr.end = scanner.getTokenEnd();
                    curr = curr.parent;
                }
                break;
            case wxmlLanguageTypes_1.TokenType.AttributeName: {
                pendingAttribute = scanner.getTokenText();
                if (!isValidAttribute(pendingAttribute)) {
                    errors.push({
                        message: `Invalid attribute ${pendingAttribute}`,
                        offsetStart: scanner.getTokenOffset(),
                        offeetEnd: scanner.getTokenEnd() - 1
                    });
                }
                let attributes = curr.attributes;
                if (!attributes) {
                    curr.attributes = attributes = {};
                }
                currOffset = scanner.getTokenOffset();
                if (pendingAttribute) {
                    attributes[pendingAttribute + `|${currOffset}`] = null; // Support valueless attributes such as 'checked'
                }
                break;
            }
            case wxmlLanguageTypes_1.TokenType.AttributeValue: {
                let value = scanner.getTokenText();
                if (!/^".*"$/.test(value)) {
                    errors.push({
                        message: `Double quote required for value`,
                        offsetStart: scanner.getTokenOffset(),
                        offeetEnd: scanner.getTokenEnd() - 1
                    });
                }
                let attributes = curr.attributes;
                if (attributes && pendingAttribute) {
                    attributes[pendingAttribute + `|${currOffset}`] = value.replace(/^"/, '').replace(/"$/, '');
                    pendingAttribute = null;
                }
                break;
            }
            case wxmlLanguageTypes_1.TokenType.Content: {
                let text = scanner.getTokenText().trim();
                if (text) {
                    curr.textContents.push(text);
                }
                break;
            }
        }
        token = scanner.scan();
    }
    while (curr.parent) {
        curr.end = text.length;
        curr.closed = false;
        curr = curr.parent;
    }
    if (tagStack.length) {
        for (let item of tagStack) {
            let parts = item.toLowerCase().split('|');
            errors.push({
                message: `Close tag not found for <${parts[0]}>`,
                offsetStart: parseInt(parts[1], 10),
                offeetEnd: parseInt(parts[2], 10) - 1,
            });
        }
    }
    return {
        roots: wxmlDocument.children,
        findNodeBefore: wxmlDocument.findNodeBefore.bind(wxmlDocument),
        findNodeAt: wxmlDocument.findNodeAt.bind(wxmlDocument),
        errors,
    };
}
exports.parse = parse;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", { value: true });
exports.createScanner = void 0;
const wxmlLanguageTypes_1 = __webpack_require__(42);
class MultiLineStream {
    constructor(source, position) {
        this.source = source;
        this.len = source.length;
        this.position = position;
    }
    eos() {
        return this.len <= this.position;
    }
    getSource() {
        return this.source;
    }
    pos() {
        return this.position;
    }
    goBackTo(pos) {
        this.position = pos;
    }
    goBack(n) {
        this.position -= n;
    }
    advance(n) {
        this.position += n;
    }
    goToEnd() {
        this.position = this.source.length;
    }
    nextChar() {
        return this.source.charCodeAt(this.position++) || 0;
    }
    peekChar(n = 0) {
        return this.source.charCodeAt(this.position + n) || 0;
    }
    advanceIfChar(ch) {
        if (ch === this.source.charCodeAt(this.position)) {
            this.position++;
            return true;
        }
        return false;
    }
    advanceIfChars(ch) {
        let i;
        if (this.position + ch.length > this.source.length) {
            return false;
        }
        for (i = 0; i < ch.length; i++) {
            if (this.source.charCodeAt(this.position + i) !== ch[i]) {
                return false;
            }
        }
        this.advance(i);
        return true;
    }
    advanceIfRegExp(regex) {
        let str = this.source.substr(this.position);
        let match = str.match(regex);
        if (match) {
            this.position = this.position + match.index + match[0].length;
            return match[0];
        }
        return '';
    }
    advanceUntilRegExp(regex) {
        let str = this.source.substr(this.position);
        let match = str.match(regex);
        if (match) {
            this.position = this.position + match.index;
            return match[0];
        }
        else {
            this.goToEnd();
        }
        return '';
    }
    advanceUntilChar(ch) {
        while (this.position < this.source.length) {
            if (this.source.charCodeAt(this.position) === ch) {
                return true;
            }
            this.advance(1);
        }
        return false;
    }
    advanceUntilChars(ch) {
        while (this.position + ch.length <= this.source.length) {
            let i = 0;
            for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) { } // tslint:disable-line
            if (i === ch.length) {
                return true;
            }
            this.advance(1);
        }
        this.goToEnd();
        return false;
    }
    skipWhitespace() {
        let n = this.advanceWhileChar(ch => (ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR));
        return n > 0;
    }
    advanceWhileChar(condition) {
        let posNow = this.position;
        while (this.position < this.len &&
            condition(this.source.charCodeAt(this.position))) {
            this.position++;
        }
        return this.position - posNow;
    }
}
const _BNG = '!'.charCodeAt(0);
const _MIN = '-'.charCodeAt(0);
const _LAN = '<'.charCodeAt(0);
const _RAN = '>'.charCodeAt(0);
const _FSL = '/'.charCodeAt(0);
const _EQS = '='.charCodeAt(0);
const _DQO = '"'.charCodeAt(0);
const _SQO = "'".charCodeAt(0);
const _NWL = '\n'.charCodeAt(0);
const _CAR = '\r'.charCodeAt(0);
const _LFD = '\f'.charCodeAt(0);
const _WSP = ' '.charCodeAt(0);
const _TAB = '\t'.charCodeAt(0);
function createScanner(input, initialOffset = 0, initialState = wxmlLanguageTypes_1.ScannerState.WithinContent) {
    let stream = new MultiLineStream(input, initialOffset);
    let state = initialState;
    let tokenOffset = 0;
    let tokenType = wxmlLanguageTypes_1.TokenType.Unknown;
    let tokenError;
    let hasSpaceAfterTag;
    let lastTag;
    let lastAttributeName;
    function nextElementName() {
        return stream.advanceIfRegExp(/^[_:\w][_:\w-.\d]*/).toLowerCase();
    }
    function nextAttributeName() {
        return stream
            .advanceIfRegExp(/^[^\s"'>/=\x00-\x0F\x7F\x80-\x9F]*/)
            .toLowerCase();
    }
    function finishToken(offset, type, errorMessage) {
        tokenType = type;
        tokenOffset = offset;
        tokenError = errorMessage;
        return type;
    }
    function scan() {
        let offset = stream.pos();
        let oldState = state;
        let token = internalScan();
        if (token !== wxmlLanguageTypes_1.TokenType.EOS && offset === stream.pos()) {
            console.log('Scanner.scan has not advanced at offset ' +
                offset +
                ', state before: ' +
                oldState +
                ' after: ' +
                state);
            stream.advance(1);
            return finishToken(offset, wxmlLanguageTypes_1.TokenType.Unknown);
        }
        return token;
    }
    function internalScan() {
        let offset = stream.pos();
        if (stream.eos()) {
            return finishToken(offset, wxmlLanguageTypes_1.TokenType.EOS);
        }
        let errorMessage;
        switch (state) {
            case wxmlLanguageTypes_1.ScannerState.WithinComment:
                if (stream.advanceIfChars([_MIN, _MIN, _RAN])) {
                    // -->
                    state = wxmlLanguageTypes_1.ScannerState.WithinContent;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.EndCommentTag);
                }
                stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->
                return finishToken(offset, wxmlLanguageTypes_1.TokenType.Comment);
            case wxmlLanguageTypes_1.ScannerState.WithinContent:
                if (stream.advanceIfChar(_LAN)) {
                    // <
                    if (!stream.eos() && stream.peekChar() === _BNG) {
                        // !
                        if (stream.advanceIfChars([_BNG, _MIN, _MIN])) {
                            // <!--
                            state = wxmlLanguageTypes_1.ScannerState.WithinComment;
                            return finishToken(offset, wxmlLanguageTypes_1.TokenType.StartCommentTag);
                        }
                    }
                    if (stream.advanceIfChar(_FSL)) {
                        // /
                        state = wxmlLanguageTypes_1.ScannerState.AfterOpeningEndTag;
                        return finishToken(offset, wxmlLanguageTypes_1.TokenType.EndTagOpen);
                    }
                    state = wxmlLanguageTypes_1.ScannerState.AfterOpeningStartTag;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.StartTagOpen);
                }
                stream.advanceUntilChar(_LAN);
                return finishToken(offset, wxmlLanguageTypes_1.TokenType.Content);
            case wxmlLanguageTypes_1.ScannerState.AfterOpeningEndTag:
                let tagName = nextElementName();
                if (tagName.length > 0) {
                    state = wxmlLanguageTypes_1.ScannerState.WithinEndTag;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.EndTag);
                }
                if (stream.skipWhitespace()) {
                    // white space is not valid here
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace, 'Tag name must directly follow the open bracket.');
                }
                state = wxmlLanguageTypes_1.ScannerState.WithinEndTag;
                stream.advanceUntilChar(_RAN);
                if (offset < stream.pos()) {
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Unknown, 'End tag name expected.');
                }
                return internalScan();
            case wxmlLanguageTypes_1.ScannerState.WithinEndTag:
                if (stream.skipWhitespace()) {
                    // white space is valid here
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace);
                }
                if (stream.advanceIfChar(_RAN)) {
                    // >
                    state = wxmlLanguageTypes_1.ScannerState.WithinContent;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.EndTagClose);
                }
                errorMessage = 'Closing bracket expected.';
                break;
            case wxmlLanguageTypes_1.ScannerState.AfterOpeningStartTag:
                lastTag = nextElementName();
                lastAttributeName = void 0;
                if (lastTag.length > 0) {
                    hasSpaceAfterTag = false;
                    state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.StartTag);
                }
                if (stream.skipWhitespace()) {
                    // white space is not valid here
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace, 'Tag name must directly follow the open bracket.');
                }
                state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                stream.advanceUntilChar(_RAN);
                if (offset < stream.pos()) {
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Unknown, 'Start tag name expected.');
                }
                return internalScan();
            case wxmlLanguageTypes_1.ScannerState.WithinTag:
                if (stream.skipWhitespace()) {
                    hasSpaceAfterTag = true; // remember that we have seen a whitespace
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace);
                }
                if (hasSpaceAfterTag) {
                    lastAttributeName = nextAttributeName();
                    if (lastAttributeName.length > 0) {
                        state = wxmlLanguageTypes_1.ScannerState.AfterAttributeName;
                        hasSpaceAfterTag = false;
                        return finishToken(offset, wxmlLanguageTypes_1.TokenType.AttributeName);
                    }
                }
                if (stream.advanceIfChars([_FSL, _RAN])) {
                    // />
                    state = wxmlLanguageTypes_1.ScannerState.WithinContent;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.StartTagSelfClose);
                }
                if (stream.advanceIfChar(_RAN)) {
                    // >
                    if (lastTag === 'wxs') {
                        state = wxmlLanguageTypes_1.ScannerState.WithinScriptContent;
                    }
                    else {
                        state = wxmlLanguageTypes_1.ScannerState.WithinContent;
                    }
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.StartTagClose);
                }
                stream.advance(1);
                return finishToken(offset, wxmlLanguageTypes_1.TokenType.Unknown, 'Unexpected character in tag.');
            case wxmlLanguageTypes_1.ScannerState.AfterAttributeName:
                if (stream.skipWhitespace()) {
                    hasSpaceAfterTag = true;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace);
                }
                if (stream.advanceIfChar(_EQS)) {
                    state = wxmlLanguageTypes_1.ScannerState.BeforeAttributeValue;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.DelimiterAssign);
                }
                state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                return internalScan(); // no advance yet - jump to WithinTag
            case wxmlLanguageTypes_1.ScannerState.BeforeAttributeValue:
                if (stream.skipWhitespace()) {
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Whitespace);
                }
                let attributeValue = stream.advanceIfRegExp(/^[^\s"'`=<>\/]+/);
                if (attributeValue.length > 0) {
                    state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                    hasSpaceAfterTag = false;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.AttributeValue);
                }
                let ch = stream.peekChar();
                if (ch === _SQO || ch === _DQO) {
                    stream.advance(1); // consume quote
                    if (stream.advanceUntilChar(ch)) {
                        stream.advance(1); // consume quote
                    }
                    state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                    hasSpaceAfterTag = false;
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.AttributeValue);
                }
                state = wxmlLanguageTypes_1.ScannerState.WithinTag;
                hasSpaceAfterTag = false;
                return internalScan(); // no advance yet - jump to WithinTag
            case wxmlLanguageTypes_1.ScannerState.WithinScriptContent:
                // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly
                let sciptState = 1;
                while (!stream.eos()) {
                    let match = stream.advanceIfRegExp(/<!--|-->|<\/?wxs\s*\/?>?/i);
                    if (match.length === 0) {
                        stream.goToEnd();
                        return finishToken(offset, wxmlLanguageTypes_1.TokenType.Script);
                    }
                    else if (match === '<!--') {
                        if (sciptState === 1) {
                            sciptState = 2;
                        }
                    }
                    else if (match === '-->') {
                        sciptState = 1;
                    }
                    else if (match[1] !== '/') {
                        // <script
                        if (sciptState === 2) {
                            sciptState = 3;
                        }
                    }
                    else {
                        // </script
                        if (sciptState === 3) {
                            sciptState = 2;
                        }
                        else {
                            stream.goBack(match.length); // to the beginning of the closing tag
                            break;
                        }
                    }
                }
                state = wxmlLanguageTypes_1.ScannerState.WithinContent;
                if (offset < stream.pos()) {
                    return finishToken(offset, wxmlLanguageTypes_1.TokenType.Script);
                }
                return internalScan(); // no advance yet - jump to content
        }
        stream.advance(1);
        state = wxmlLanguageTypes_1.ScannerState.WithinContent;
        return finishToken(offset, wxmlLanguageTypes_1.TokenType.Unknown, errorMessage);
    }
    return {
        scan,
        getTokenType: () => tokenType,
        getTokenOffset: () => tokenOffset,
        getTokenLength: () => stream.pos() - tokenOffset,
        getTokenEnd: () => stream.pos(),
        getTokenText: () => stream.getSource().substring(tokenOffset, stream.pos()),
        getScannerState: () => state,
        getTokenError: () => tokenError,
    };
}
exports.createScanner = createScanner;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScannerState = exports.TokenType = void 0;
var TokenType;
(function (TokenType) {
    TokenType[TokenType["StartCommentTag"] = 0] = "StartCommentTag";
    TokenType[TokenType["Comment"] = 1] = "Comment";
    TokenType[TokenType["EndCommentTag"] = 2] = "EndCommentTag";
    TokenType[TokenType["StartTagOpen"] = 3] = "StartTagOpen";
    TokenType[TokenType["StartTagClose"] = 4] = "StartTagClose";
    TokenType[TokenType["StartTagSelfClose"] = 5] = "StartTagSelfClose";
    TokenType[TokenType["StartTag"] = 6] = "StartTag";
    TokenType[TokenType["EndTagOpen"] = 7] = "EndTagOpen";
    TokenType[TokenType["EndTagClose"] = 8] = "EndTagClose";
    TokenType[TokenType["EndTag"] = 9] = "EndTag";
    TokenType[TokenType["DelimiterAssign"] = 10] = "DelimiterAssign";
    TokenType[TokenType["AttributeName"] = 11] = "AttributeName";
    TokenType[TokenType["AttributeValue"] = 12] = "AttributeValue";
    TokenType[TokenType["Content"] = 13] = "Content";
    TokenType[TokenType["Whitespace"] = 14] = "Whitespace";
    TokenType[TokenType["Unknown"] = 15] = "Unknown";
    TokenType[TokenType["Script"] = 16] = "Script";
    TokenType[TokenType["EOS"] = 17] = "EOS";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
var ScannerState;
(function (ScannerState) {
    ScannerState[ScannerState["WithinContent"] = 0] = "WithinContent";
    ScannerState[ScannerState["AfterOpeningStartTag"] = 1] = "AfterOpeningStartTag";
    ScannerState[ScannerState["AfterOpeningEndTag"] = 2] = "AfterOpeningEndTag";
    ScannerState[ScannerState["WithinDoctype"] = 3] = "WithinDoctype";
    ScannerState[ScannerState["WithinTag"] = 4] = "WithinTag";
    ScannerState[ScannerState["WithinEndTag"] = 5] = "WithinEndTag";
    ScannerState[ScannerState["WithinComment"] = 6] = "WithinComment";
    ScannerState[ScannerState["WithinScriptContent"] = 7] = "WithinScriptContent";
    ScannerState[ScannerState["WithinStyleContent"] = 8] = "WithinStyleContent";
    ScannerState[ScannerState["AfterAttributeName"] = 9] = "AfterAttributeName";
    ScannerState[ScannerState["BeforeAttributeValue"] = 10] = "BeforeAttributeValue";
})(ScannerState = exports.ScannerState || (exports.ScannerState = {}));


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
exports.binarySearch = exports.findFirst = void 0;
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
function findFirst(array, p) {
    let low = 0;
    let high = array.length;
    if (high === 0) {
        return 0;
    }
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (p(array[mid])) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    return low;
}
exports.findFirst = findFirst;
function binarySearch(array, key, comparator) {
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        let comp = comparator(array[mid], key);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
exports.binarySearch = binarySearch;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWXMLTagProvider = exports.WXML_TAGS = exports.isSubAttrTag = exports.WXMLTagSpecification = exports.isEmptyElement = exports.EMPTY_ELEMENTS = void 0;
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const arrays = __importStar(__webpack_require__(43));
const strings = __importStar(__webpack_require__(45));
const fs = __webpack_require__(36);
const path = __webpack_require__(15);
exports.EMPTY_ELEMENTS = [
    'audio',
    'video',
    'camera',
    'checkbox',
    'cover-image',
    'icon',
    'image',
    'input',
    'live-player',
    'live-pusher',
    'map',
    'open-data',
    'progress',
    'radio',
    'slider',
    'switch',
];
function isEmptyElement(e) {
    return (!!e &&
        arrays.binarySearch(exports.EMPTY_ELEMENTS, e.toLowerCase(), (s1, s2) => s1.localeCompare(s2)) >= 0);
}
exports.isEmptyElement = isEmptyElement;
function getSubAttribute(spec) {
    let attrs = spec.attrs;
    if (!attrs)
        return null;
    for (let attr of attrs) {
        if (attr.hasOwnProperty('subAttrs')) {
            return attr;
        }
    }
    return null;
}
class WXMLTagSpecification {
    constructor(config) {
        this.attrs = [];
        for (let key of Object.keys(config)) {
            this[key] = config[key];
        }
    }
}
exports.WXMLTagSpecification = WXMLTagSpecification;
function isSubAttrTag(tag) {
    for (let name of Object.keys(exports.WXML_TAGS)) {
        if (name === tag) {
            return exports.WXML_TAGS[name].subAttr === true;
        }
    }
    return false;
}
exports.isSubAttrTag = isSubAttrTag;
exports.WXML_TAGS = (() => {
    let componentConfig = fs.readFileSync(path.resolve(__dirname, '../components.json'), 'utf8');
    let componentList = JSON.parse(componentConfig);
    let TAGS = {};
    for (let item of componentList) {
        TAGS[item.name] = new WXMLTagSpecification(item);
        let subAttr = getSubAttribute(item);
        if (subAttr) {
            TAGS[item.name].subAttr = true;
            let attrs = subAttr.subAttrs;
            for (let attr of attrs) {
                let name = `$${item.name} ${attr.equal}`;
                let spec = {
                    name,
                    attrs: attr.attrs,
                };
                TAGS[name] = new WXMLTagSpecification(spec);
            }
        }
        if (item.name === 'input' || item.name === 'textarea') {
            let spec = TAGS[item.name];
            spec.attrs.push({
                name: 'name',
                type: {
                    name: 'string',
                },
                desc: ['field name']
            });
        }
    }
    TAGS.wxs = new WXMLTagSpecification({
        name: 'wxs',
        desc: ['WeiXin Script'],
        docLink: 'https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/index.html',
        tips: ['WXSWeiXin Script WXML'],
        attrs: [{
                name: 'module',
                type: {
                    name: 'string',
                },
                desc: [
                    'global variable name'
                ],
            }]
    });
    return TAGS;
})();
function getWXMLTagProvider() {
    let globalAttributes = [
        'id:string',
        'class:string',
        'style:string',
        'hidden:boolean'
    ];
    let eventNames = ['tap', 'touchstart', 'touchmove', 'touchcancel', 'touchend',
        'longpress', 'longtap', 'transitionend', 'animationstart',
        'animationiteration', 'animationend', 'touchforcechange'];
    let eventHandlers = [];
    let logicAttributes = ['wx:if', 'wx:elif', 'wx:else'];
    let iterateAttributes = ['wx:for', 'wx:item', 'wx:index', 'wx:key', 'wx:for-item', 'wx:for-index', 'wx:for-items'];
    for (let name of eventNames) {
        eventHandlers.push(`bind:${name}`, `catch:${name}`, `catch${name}`, `bind${name}`);
    }
    let valueSets = {
        boolean: ['true', 'false']
    };
    return {
        getId: () => 'wxml',
        isApplicable: () => true,
        collectTags: (collector) => collectTagsDefault(collector, exports.WXML_TAGS),
        collectAttributes: (tag, collector) => {
            collectAttributesDefault(tag, collector, exports.WXML_TAGS, globalAttributes);
            for (let handler of eventHandlers) {
                collector(handler, 'event');
            }
            for (let attr of logicAttributes) {
                collector(attr, 'logic');
            }
            for (let attr of iterateAttributes) {
                collector(attr, 'iterate');
            }
        },
        collectValues: (tag, attribute, collector) => collectValuesDefault(tag, attribute, collector, exports.WXML_TAGS, globalAttributes, valueSets),
    };
}
exports.getWXMLTagProvider = getWXMLTagProvider;
function collectTagsDefault(collector, tagSet) {
    for (let tag of Object.keys(tagSet)) {
        // tag of sub attr
        if (tag[0] !== '$') {
            collector(tag, tagSet[tag]);
        }
    }
}
function collectAttributesDefault(tagName, collector, tagSet, globalAttributes) {
    if (tagName) {
        let tag = tagSet[tagName];
        if (tag) {
            for (let attr of tag.attrs) {
                collector(attr.name, attr.type.name, attr);
            }
        }
    }
    for (let attr of globalAttributes) {
        let segments = attr.split(':');
        collector(segments[0], segments[1]);
    }
}
function collectValuesDefault(tagName, attribute, collector, tagSet, globalAttributes, valueSets) {
    let prefix = attribute + ':';
    for (let attr of globalAttributes) {
        if (attr.length > prefix.length && strings.startsWith(attr, prefix)) {
            let typeInfo = attr.substr(prefix.length);
            let values = valueSets[typeInfo];
            if (values) {
                for (let value of values) {
                    collector(value);
                }
            }
            return;
        }
    }
    if (tagName) {
        let tag = tagSet[tagName];
        if (tag) {
            let attr = tag.attrs.find(o => o.name === attribute);
            if (attr) {
                if (attr.type.name === 'boolean') {
                    let values = valueSets.boolean;
                    for (let value of values) {
                        collector(value);
                    }
                }
                if (Array.isArray(attr.enum)) {
                    for (let item of attr.enum) {
                        collector(item.value, item);
                    }
                }
            }
        }
    }
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
exports.isLetterOrDigit = exports.repeat = exports.commonPrefixLength = exports.endsWith = exports.startsWith = void 0;
function startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    for (let i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
exports.startsWith = startsWith;
/**
 * Determines if haystack ends with needle.
 */
function endsWith(haystack, needle) {
    let diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.lastIndexOf(needle) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
exports.endsWith = endsWith;
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    let i;
    let len = Math.min(a.length, b.length);
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
exports.commonPrefixLength = commonPrefixLength;
function repeat(value, count) {
    let s = '';
    while (count > 0) {
        if ((count & 1) === 1) {
            s += value;
        }
        value += value;
        count = count >>> 1;
    }
    return s;
}
exports.repeat = repeat;
const _a = 'a'.charCodeAt(0);
const _z = 'z'.charCodeAt(0);
const _A = 'A'.charCodeAt(0);
const _Z = 'Z'.charCodeAt(0);
const _0 = '0'.charCodeAt(0);
const _9 = '9'.charCodeAt(0);
function isLetterOrDigit(text, index) {
    let c = text.charCodeAt(index);
    return (_a <= c && c <= _z) || (_A <= c && c <= _Z) || (_0 <= c && c <= _9);
}
exports.isLetterOrDigit = isLetterOrDigit;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(20);
const wxmlTags_1 = __webpack_require__(44);
const path = __webpack_require__(15);
const fs = __webpack_require__(36);
function isDynamicValue(value) {
    return /^\{\{.+\}\}$/.test(value);
}
function isNumberValue(value) {
    if (!value)
        return true;
    return /^-?\d+(?:\.\d+)?$/.test(value);
}
function doDiagnostic(document, wxmlDocument) {
    let errors = wxmlDocument.errors;
    let result = [];
    for (let error of errors) {
        let range = {
            start: document.positionAt(error.offsetStart),
            end: document.positionAt(error.offeetEnd)
        };
        result.push({
            range,
            severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
            message: `Parse error: ${error.message}`
        });
    }
    let provider = wxmlTags_1.getWXMLTagProvider();
    let globalTags = [];
    provider.collectTags(name => {
        globalTags.push(name);
    });
    let uri = document.uri;
    function iterate(node) {
        let tag = node.tag;
        if (tag == null)
            return;
        if (wxmlTags_1.EMPTY_ELEMENTS.indexOf(tag) !== -1 && !node.isEmpty) {
            result.push({
                range: {
                    start: document.positionAt(node.start),
                    end: document.positionAt(node.end)
                },
                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                message: 'Empty tag should not have children'
            });
        }
        if (tag === 'text') {
            let find = node.children.find(o => o.tag !== 'text');
            if (find) {
                result.push({
                    range: {
                        start: document.positionAt(find.start),
                        end: document.positionAt(find.end)
                    },
                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                    message: `${find.tag} not allowed in <text>`
                });
            }
        }
        if (tag === 'include' || tag === 'import') {
            let srcValue = node.getAttributeValue('src');
            if (/^file:\/\//.test(uri) && srcValue) {
                let dir = path.dirname(uri.replace(/^file:\/\//, ''));
                let fullPath = path.resolve(dir, srcValue);
                if (!fs.existsSync(fullPath)) {
                    let start = node.getValueOffset('src');
                    if (start) {
                        result.push({
                            range: {
                                start: document.positionAt(start),
                                end: document.positionAt(start + srcValue.length - 1)
                            },
                            severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                            message: `File ${fullPath} not exist`
                        });
                    }
                }
            }
        }
        // check duplicated attributes
        let duplicatedAttrs = node.getDuplicatedAttrs();
        if (duplicatedAttrs.length) {
            for (let attr of duplicatedAttrs) {
                let offsets = node.getAttributeOffsets(attr);
                for (let offset of offsets) {
                    result.push({
                        range: {
                            start: document.positionAt(offset),
                            end: document.positionAt(offset + attr.length)
                        },
                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                        message: `Duplicated attribute "${attr}"`
                    });
                }
            }
        }
        if (globalTags.indexOf(tag) !== -1) {
            let attributes = node.attributeNames;
            let allowedAttrs = {};
            provider.collectAttributes(tag, (name, type, info) => {
                allowedAttrs[name] = {
                    type: type || 'string',
                    info
                };
            });
            if (wxmlTags_1.isSubAttrTag(tag)) {
                let mode = node.getAttributeValue('mode');
                if (mode) {
                    provider.collectAttributes(`$${tag} ${mode}`, (name, type, info) => {
                        allowedAttrs[name] = {
                            type: type || 'string',
                            info
                        };
                    });
                }
            }
            let allowedAttrsNames = Object.keys(allowedAttrs);
            for (let attr of attributes) {
                let value = node.getAttributeValue(attr);
                let offset = node.getAttributeOffsets(attr)[0];
                if (/data-/.test(attr))
                    continue;
                if (allowedAttrsNames.indexOf(attr) === -1) {
                    if (offset) {
                        result.push({
                            range: {
                                start: document.positionAt(offset),
                                end: document.positionAt(offset + attr.length)
                            },
                            severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                            message: `Unknown attribute "${attr}"`
                        });
                    }
                    continue;
                }
                if (attr === 'wx:else') {
                    if (value) {
                        result.push({
                            range: {
                                start: document.positionAt(offset),
                                end: document.positionAt(offset + attr.length)
                            },
                            severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,
                            message: `Unnecessary value for "${attr}"`
                        });
                    }
                    continue;
                }
                if (value && isDynamicValue(value))
                    continue;
                let type = allowedAttrs[attr].type;
                switch (type) {
                    case 'logic':
                    case 'iterate':
                    case 'event':
                    case 'function':
                        if (!value) {
                            result.push({
                                range: {
                                    start: document.positionAt(offset),
                                    end: document.positionAt(offset + attr.length)
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Value required for attribute "${attr}"`
                            });
                        }
                        else if (['wx:for', 'wx:for-items'].indexOf(attr) !== -1) {
                            result.push({
                                range: {
                                    start: document.positionAt(offset),
                                    end: document.positionAt(offset + attr.length)
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Expression required for attribute "${attr}"`
                            });
                        }
                        break;
                    case 'boolean':
                        if (value && ['true', 'false'].indexOf(value) === -1) {
                            let valueOffset = node.getValueOffset(attr) || offset;
                            value = value || '';
                            result.push({
                                range: {
                                    start: document.positionAt(valueOffset),
                                    end: document.positionAt(valueOffset + (value.length || 1))
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Invalid value for boolean attribute "${attr}"`
                            });
                        }
                        break;
                    case 'number':
                        if (value && !isNumberValue(value)) {
                            let valueOffset = node.getValueOffset(attr) || offset;
                            result.push({
                                range: {
                                    start: document.positionAt(valueOffset),
                                    end: document.positionAt(valueOffset + value.length)
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Invalid value for number attribute "${attr}"`
                            });
                        }
                        break;
                    default: {
                        // checke values
                        let allowedValues = [];
                        provider.collectValues(tag, attr, value => {
                            if (allowedValues.indexOf(value) === -1) {
                                allowedValues.push(value);
                            }
                        });
                        let info = allowedAttrs[attr].info;
                        let defaultValue = info ? info.defaultValue : null;
                        if (defaultValue === '' || defaultValue === 'false')
                            defaultValue = null;
                        if (!defaultValue && !value) {
                            let valueOffset = node.getValueOffset(attr) || offset;
                            result.push({
                                range: {
                                    start: document.positionAt(valueOffset),
                                    end: document.positionAt(valueOffset + 1)
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Value required for attribute "${attr}"`
                            });
                        }
                        if (value && allowedValues.length && allowedValues.indexOf(value) === -1) {
                            let valueOffset = node.getValueOffset(attr) || offset;
                            result.push({
                                range: {
                                    start: document.positionAt(valueOffset),
                                    end: document.positionAt(valueOffset + value.length)
                                },
                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                                message: `Invalid value for enum attribute "${attr}"`
                            });
                        }
                    }
                }
            }
        }
        for (let child of node.children) {
            iterate(child);
        }
    }
    for (let child of wxmlDocument.roots) {
        iterate(child);
    }
    // validate tags
    return result;
}
exports.default = doDiagnostic;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
 *******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = __webpack_require__(20);
const wxmlScanner_1 = __webpack_require__(41);
const wxmlTags_1 = __webpack_require__(44);
const wxmlTags_2 = __webpack_require__(44);
const wxmlLanguageTypes_1 = __webpack_require__(42);
const htmlEntities_1 = __webpack_require__(48);
const strings_1 = __webpack_require__(45);
function doComplete(document, position, wxmlDocument, config) {
    let result = {
        isIncomplete: false,
        items: [],
    };
    let provider = wxmlTags_2.getWXMLTagProvider();
    let text = document.getText();
    let offset = document.offsetAt(position);
    let node = wxmlDocument.findNodeBefore(offset);
    if (!node)
        return result;
    let scanner = wxmlScanner_1.createScanner(text, node.start);
    let currentTag = '';
    let currentAttributeName;
    function getReplaceRange(replaceStart, replaceEnd = offset) {
        if (replaceStart > offset) {
            replaceStart = offset;
        }
        return {
            start: document.positionAt(replaceStart),
            end: document.positionAt(replaceEnd),
        };
    }
    function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {
        let range = getReplaceRange(afterOpenBracket, tagNameEnd);
        provider.collectTags((tag, info) => {
            result.items.push({
                label: tag,
                kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                documentation: info && info.desc ? info.desc.join('\n') : '',
                textEdit: vscode_languageserver_types_1.TextEdit.replace(range, tag),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
            });
        });
        return result;
    }
    function getLineIndent(offset) {
        let start = offset;
        while (start > 0) {
            let ch = text.charAt(start - 1);
            if ('\n\r'.indexOf(ch) >= 0) {
                return text.substring(start, offset);
            }
            if (!isWhiteSpace(ch)) {
                return null;
            }
            start--;
        }
        return text.substring(0, offset);
    }
    function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd = offset) {
        let range = getReplaceRange(afterOpenBracket, tagNameEnd);
        let closeTag = isFollowedBy(text, tagNameEnd, wxmlLanguageTypes_1.ScannerState.WithinEndTag, wxmlLanguageTypes_1.TokenType.EndTagClose) ? '' : '>';
        let curr = node;
        if (inOpenTag) {
            curr = curr.parent; // don't suggest the own tag, it's not yet open
        }
        while (curr) {
            let tag = curr.tag;
            if (tag &&
                (!curr.closed || (curr.endTagStart && curr.endTagStart > offset))) {
                let item = {
                    label: '/' + tag,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    filterText: '/' + tag + closeTag,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                };
                let startIndent = getLineIndent(curr.start);
                let endIndent = getLineIndent(afterOpenBracket - 1);
                if (startIndent !== null &&
                    endIndent !== null &&
                    startIndent !== endIndent) {
                    let insertText = startIndent + '</' + tag + closeTag;
                    item.textEdit = vscode_languageserver_types_1.TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);
                    item.filterText = endIndent + '</' + tag + closeTag;
                }
                result.items.push(item);
                return result;
            }
            curr = curr.parent;
        }
        if (inOpenTag) {
            return result;
        }
        provider.collectTags((tag, info) => {
            result.items.push({
                label: '/' + tag,
                kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                documentation: info && info.desc ? info.desc.join('\n') : '',
                filterText: '/' + tag + closeTag,
                textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
            });
        });
        return result;
    }
    function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {
        if (!wxmlTags_1.isEmptyElement(tag)) {
            let pos = document.positionAt(tagCloseEnd);
            result.items.push({
                label: '</' + tag + '>',
                kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                filterText: '</' + tag + '>',
                textEdit: vscode_languageserver_types_1.TextEdit.insert(pos, '$0</' + tag + '>'),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
            });
        }
        return result;
    }
    function collectTagSuggestions(tagStart, tagEnd) {
        collectOpenTagSuggestions(tagStart, tagEnd);
        collectCloseTagSuggestions(tagStart, true, tagEnd);
        return result;
    }
    function collectAttributeNameSuggestions(tag, nameStart, nameEnd = offset) {
        if (!wxmlTags_2.isSubAttrTag(tag)) {
            let replaceEnd = offset;
            while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {
                // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.
                replaceEnd++;
            }
            let isSnippet = config.useSnippet && !isFollowedBy(text, nameEnd, wxmlLanguageTypes_1.ScannerState.AfterAttributeName, wxmlLanguageTypes_1.TokenType.DelimiterAssign);
            let range = getReplaceRange(nameStart, replaceEnd);
            let value = isSnippet ? '="$1"' : '';
            let seenAttributes = Object.create(null);
            for (let attr of node.attributeNames) {
                seenAttributes[attr] = true;
            }
            provider.collectAttributes(tag, (attribute, type, info) => {
                if (seenAttributes[attribute])
                    return;
                seenAttributes[attribute] = true;
                if (/^(bind|catch):/.test(attribute)) {
                    seenAttributes[attribute.replace(':', '')] = true;
                    if (config.completeEvent === false)
                        return;
                }
                if (/^\$/.test(tag) && /:/.test(attribute))
                    return;
                let codeSnippet = attribute;
                let useSnippet = isSnippet && type !== 'boolean';
                if (type !== 'boolean' && isSnippet) {
                    codeSnippet = codeSnippet + value;
                }
                let command;
                if (useSnippet) {
                    command = {
                        title: 'Suggest',
                        command: 'editor.action.triggerSuggest'
                    };
                }
                result.items.push({
                    label: attribute,
                    documentation: info && info.desc ? info.desc.join('\n') : '',
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, codeSnippet),
                    insertTextFormat: useSnippet ? vscode_languageserver_types_1.InsertTextFormat.Snippet : vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    command
                });
            });
            return result;
        }
        else {
            let mode = node.getAttributeValue('mode');
            let name = mode ? `$${tag} ${mode}` : tag;
            return collectAttributeNameSuggestions(name, nameStart, nameEnd);
        }
    }
    function collectAttributeValueSuggestions(valueStart, valueEnd = offset) {
        let range;
        let addQuotes;
        if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {
            // inside quoted attribute
            let valueContentStart = valueStart + 1;
            let valueContentEnd = valueEnd;
            // valueEnd points to the char after quote, which encloses the replace range
            if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {
                valueContentEnd--;
            }
            let wsBefore = getWordStart(text, offset, valueContentStart);
            let wsAfter = getWordEnd(text, offset, valueContentEnd);
            range = getReplaceRange(wsBefore, wsAfter);
            addQuotes = false;
        }
        else {
            range = getReplaceRange(valueStart, valueEnd);
            addQuotes = true;
        }
        let tag = currentTag.toLowerCase();
        let attribute = currentAttributeName.toLowerCase();
        provider.collectValues(tag, attribute, (value, info) => {
            let insertText = addQuotes ? '"' + value + '"' : value;
            result.items.push({
                label: value,
                filterText: insertText,
                kind: vscode_languageserver_types_1.CompletionItemKind.Enum,
                documentation: info && info.desc ? info.desc : '',
                textEdit: vscode_languageserver_types_1.TextEdit.replace(range, insertText),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
            });
        });
        return result;
    }
    function scanNextForEndPos(nextToken) {
        if (offset === scanner.getTokenEnd()) {
            token = scanner.scan();
            if (token === nextToken && scanner.getTokenOffset() === offset) {
                return scanner.getTokenEnd();
            }
        }
        return offset;
    }
    function collectCharacterEntityProposals() {
        // character entities
        let k = offset - 1;
        let characterStart = position.character;
        while (k >= 0 && strings_1.isLetterOrDigit(text, k)) {
            k--;
            characterStart--;
        }
        if (k >= 0 && text[k] === '&') {
            let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(position.line, characterStart - 1), position);
            for (let entity in htmlEntities_1.entities) {
                if (strings_1.endsWith(entity, ';')) {
                    const label = '&' + entity;
                    result.items.push({
                        label,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Keyword,
                        documentation: `Character entity representing '${htmlEntities_1.entities[entity]}'`,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, label),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    });
                }
            }
        }
        return result;
    }
    let token = scanner.scan();
    while (token !== wxmlLanguageTypes_1.TokenType.EOS && scanner.getTokenOffset() <= offset) {
        switch (token) {
            case wxmlLanguageTypes_1.TokenType.StartTagOpen:
                if (scanner.getTokenEnd() === offset) {
                    let endPos = scanNextForEndPos(wxmlLanguageTypes_1.TokenType.StartTag);
                    return collectTagSuggestions(offset, endPos);
                }
                break;
            case wxmlLanguageTypes_1.TokenType.StartTag:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                currentTag = scanner.getTokenText();
                break;
            case wxmlLanguageTypes_1.TokenType.AttributeName:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectAttributeNameSuggestions(currentTag.toLowerCase(), scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                currentAttributeName = scanner.getTokenText();
                break;
            case wxmlLanguageTypes_1.TokenType.DelimiterAssign:
                if (scanner.getTokenEnd() === offset) {
                    let endPos = scanNextForEndPos(wxmlLanguageTypes_1.TokenType.AttributeValue);
                    return collectAttributeValueSuggestions(offset, endPos);
                }
                break;
            case wxmlLanguageTypes_1.TokenType.AttributeValue:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                break;
            case wxmlLanguageTypes_1.TokenType.Whitespace:
                if (offset <= scanner.getTokenEnd()) {
                    switch (scanner.getScannerState()) {
                        case wxmlLanguageTypes_1.ScannerState.AfterOpeningStartTag:
                            let startPos = scanner.getTokenOffset();
                            let endTagPos = scanNextForEndPos(wxmlLanguageTypes_1.TokenType.StartTag);
                            return collectTagSuggestions(startPos, endTagPos);
                        case wxmlLanguageTypes_1.ScannerState.WithinTag:
                        case wxmlLanguageTypes_1.ScannerState.AfterAttributeName:
                            return collectAttributeNameSuggestions(currentTag.toLowerCase(), scanner.getTokenEnd());
                        case wxmlLanguageTypes_1.ScannerState.BeforeAttributeValue:
                            return collectAttributeValueSuggestions(scanner.getTokenEnd());
                        case wxmlLanguageTypes_1.ScannerState.AfterOpeningEndTag:
                            return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                        case wxmlLanguageTypes_1.ScannerState.WithinContent:
                            return collectCharacterEntityProposals();
                    }
                }
                break;
            case wxmlLanguageTypes_1.TokenType.EndTagOpen:
                if (offset <= scanner.getTokenEnd()) {
                    let afterOpenBracket = scanner.getTokenOffset() + 1;
                    let endOffset = scanNextForEndPos(wxmlLanguageTypes_1.TokenType.EndTag);
                    return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);
                }
                break;
            case wxmlLanguageTypes_1.TokenType.EndTag:
                if (offset <= scanner.getTokenEnd()) {
                    let start = scanner.getTokenOffset() - 1;
                    while (start >= 0) {
                        let ch = text.charAt(start);
                        if (ch === '/') {
                            return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());
                        }
                        else if (!isWhiteSpace(ch)) {
                            break;
                        }
                        start--;
                    }
                }
                break;
            case wxmlLanguageTypes_1.TokenType.StartTagClose:
                if (offset <= scanner.getTokenEnd()) {
                    if (currentTag) {
                        return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);
                    }
                }
                break;
            case wxmlLanguageTypes_1.TokenType.Content:
                if (offset <= scanner.getTokenEnd()) {
                    return collectCharacterEntityProposals();
                }
                break;
            default:
                if (offset <= scanner.getTokenEnd()) {
                    return result;
                }
                break;
        }
        token = scanner.scan();
    }
    return result;
}
exports.default = doComplete;
function isQuote(s) {
    return /^["']*$/.test(s);
}
function isWhiteSpace(s) {
    return /^\s*$/.test(s);
}
function isFollowedBy(s, offset, intialState, expectedToken) {
    let scanner = wxmlScanner_1.createScanner(s, offset, intialState);
    let token = scanner.scan();
    while (token === wxmlLanguageTypes_1.TokenType.Whitespace) {
        token = scanner.scan();
    }
    return token === expectedToken;
}
function getWordStart(s, offset, limit) {
    while (offset > limit && !isWhiteSpace(s[offset - 1])) {
        offset--;
    }
    return offset;
}
function getWordEnd(s, offset, limit) {
    while (offset < limit && !isWhiteSpace(s[offset])) {
        offset++;
    }
    return offset;
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
exports.entities = void 0;
/**
 * HTML 5 character entities
 * https://www.w3.org/TR/html5/syntax.html#named-character-references
 */
exports.entities = {
    'Aacute;': '\u00C1',
    'Aacute': '\u00C1',
    'aacute;': '\u00E1',
    'aacute': '\u00E1',
    'Abreve;': '\u0102',
    'abreve;': '\u0103',
    'ac;': '\u223E',
    'acd;': '\u223F',
    'acE;': '\u223E\u0333',
    'Acirc;': '\u00C2',
    'Acirc': '\u00C2',
    'acirc;': '\u00E2',
    'acirc': '\u00E2',
    'acute;': '\u00B4',
    'acute': '\u00B4',
    'Acy;': '\u0410',
    'acy;': '\u0430',
    'AElig;': '\u00C6',
    'AElig': '\u00C6',
    'aelig;': '\u00E6',
    'aelig': '\u00E6',
    'af;': '\u2061',
    'Afr;': '\uD835\uDD04',
    'afr;': '\uD835\uDD1E',
    'Agrave;': '\u00C0',
    'Agrave': '\u00C0',
    'agrave;': '\u00E0',
    'agrave': '\u00E0',
    'alefsym;': '\u2135',
    'aleph;': '\u2135',
    'Alpha;': '\u0391',
    'alpha;': '\u03B1',
    'Amacr;': '\u0100',
    'amacr;': '\u0101',
    'amalg;': '\u2A3F',
    'AMP;': '\u0026',
    'AMP': '\u0026',
    'amp;': '\u0026',
    'amp': '\u0026',
    'And;': '\u2A53',
    'and;': '\u2227',
    'andand;': '\u2A55',
    'andd;': '\u2A5C',
    'andslope;': '\u2A58',
    'andv;': '\u2A5A',
    'ang;': '\u2220',
    'ange;': '\u29A4',
    'angle;': '\u2220',
    'angmsd;': '\u2221',
    'angmsdaa;': '\u29A8',
    'angmsdab;': '\u29A9',
    'angmsdac;': '\u29AA',
    'angmsdad;': '\u29AB',
    'angmsdae;': '\u29AC',
    'angmsdaf;': '\u29AD',
    'angmsdag;': '\u29AE',
    'angmsdah;': '\u29AF',
    'angrt;': '\u221F',
    'angrtvb;': '\u22BE',
    'angrtvbd;': '\u299D',
    'angsph;': '\u2222',
    'angst;': '\u00C5',
    'angzarr;': '\u237C',
    'Aogon;': '\u0104',
    'aogon;': '\u0105',
    'Aopf;': '\uD835\uDD38',
    'aopf;': '\uD835\uDD52',
    'ap;': '\u2248',
    'apacir;': '\u2A6F',
    'apE;': '\u2A70',
    'ape;': '\u224A',
    'apid;': '\u224B',
    'apos;': '\u0027',
    'ApplyFunction;': '\u2061',
    'approx;': '\u2248',
    'approxeq;': '\u224A',
    'Aring;': '\u00C5',
    'Aring': '\u00C5',
    'aring;': '\u00E5',
    'aring': '\u00E5',
    'Ascr;': '\uD835\uDC9C',
    'ascr;': '\uD835\uDCB6',
    'Assign;': '\u2254',
    'ast;': '\u002A',
    'asymp;': '\u2248',
    'asympeq;': '\u224D',
    'Atilde;': '\u00C3',
    'Atilde': '\u00C3',
    'atilde;': '\u00E3',
    'atilde': '\u00E3',
    'Auml;': '\u00C4',
    'Auml': '\u00C4',
    'auml;': '\u00E4',
    'auml': '\u00E4',
    'awconint;': '\u2233',
    'awint;': '\u2A11',
    'backcong;': '\u224C',
    'backepsilon;': '\u03F6',
    'backprime;': '\u2035',
    'backsim;': '\u223D',
    'backsimeq;': '\u22CD',
    'Backslash;': '\u2216',
    'Barv;': '\u2AE7',
    'barvee;': '\u22BD',
    'Barwed;': '\u2306',
    'barwed;': '\u2305',
    'barwedge;': '\u2305',
    'bbrk;': '\u23B5',
    'bbrktbrk;': '\u23B6',
    'bcong;': '\u224C',
    'Bcy;': '\u0411',
    'bcy;': '\u0431',
    'bdquo;': '\u201E',
    'becaus;': '\u2235',
    'Because;': '\u2235',
    'because;': '\u2235',
    'bemptyv;': '\u29B0',
    'bepsi;': '\u03F6',
    'bernou;': '\u212C',
    'Bernoullis;': '\u212C',
    'Beta;': '\u0392',
    'beta;': '\u03B2',
    'beth;': '\u2136',
    'between;': '\u226C',
    'Bfr;': '\uD835\uDD05',
    'bfr;': '\uD835\uDD1F',
    'bigcap;': '\u22C2',
    'bigcirc;': '\u25EF',
    'bigcup;': '\u22C3',
    'bigodot;': '\u2A00',
    'bigoplus;': '\u2A01',
    'bigotimes;': '\u2A02',
    'bigsqcup;': '\u2A06',
    'bigstar;': '\u2605',
    'bigtriangledown;': '\u25BD',
    'bigtriangleup;': '\u25B3',
    'biguplus;': '\u2A04',
    'bigvee;': '\u22C1',
    'bigwedge;': '\u22C0',
    'bkarow;': '\u290D',
    'blacklozenge;': '\u29EB',
    'blacksquare;': '\u25AA',
    'blacktriangle;': '\u25B4',
    'blacktriangledown;': '\u25BE',
    'blacktriangleleft;': '\u25C2',
    'blacktriangleright;': '\u25B8',
    'blank;': '\u2423',
    'blk12;': '\u2592',
    'blk14;': '\u2591',
    'blk34;': '\u2593',
    'block;': '\u2588',
    'bne;': '\u003D\u20E5',
    'bnequiv;': '\u2261\u20E5',
    'bNot;': '\u2AED',
    'bnot;': '\u2310',
    'Bopf;': '\uD835\uDD39',
    'bopf;': '\uD835\uDD53',
    'bot;': '\u22A5',
    'bottom;': '\u22A5',
    'bowtie;': '\u22C8',
    'boxbox;': '\u29C9',
    'boxDL;': '\u2557',
    'boxDl;': '\u2556',
    'boxdL;': '\u2555',
    'boxdl;': '\u2510',
    'boxDR;': '\u2554',
    'boxDr;': '\u2553',
    'boxdR;': '\u2552',
    'boxdr;': '\u250C',
    'boxH;': '\u2550',
    'boxh;': '\u2500',
    'boxHD;': '\u2566',
    'boxHd;': '\u2564',
    'boxhD;': '\u2565',
    'boxhd;': '\u252C',
    'boxHU;': '\u2569',
    'boxHu;': '\u2567',
    'boxhU;': '\u2568',
    'boxhu;': '\u2534',
    'boxminus;': '\u229F',
    'boxplus;': '\u229E',
    'boxtimes;': '\u22A0',
    'boxUL;': '\u255D',
    'boxUl;': '\u255C',
    'boxuL;': '\u255B',
    'boxul;': '\u2518',
    'boxUR;': '\u255A',
    'boxUr;': '\u2559',
    'boxuR;': '\u2558',
    'boxur;': '\u2514',
    'boxV;': '\u2551',
    'boxv;': '\u2502',
    'boxVH;': '\u256C',
    'boxVh;': '\u256B',
    'boxvH;': '\u256A',
    'boxvh;': '\u253C',
    'boxVL;': '\u2563',
    'boxVl;': '\u2562',
    'boxvL;': '\u2561',
    'boxvl;': '\u2524',
    'boxVR;': '\u2560',
    'boxVr;': '\u255F',
    'boxvR;': '\u255E',
    'boxvr;': '\u251C',
    'bprime;': '\u2035',
    'Breve;': '\u02D8',
    'breve;': '\u02D8',
    'brvbar;': '\u00A6',
    'brvbar': '\u00A6',
    'Bscr;': '\u212C',
    'bscr;': '\uD835\uDCB7',
    'bsemi;': '\u204F',
    'bsim;': '\u223D',
    'bsime;': '\u22CD',
    'bsol;': '\u005C',
    'bsolb;': '\u29C5',
    'bsolhsub;': '\u27C8',
    'bull;': '\u2022',
    'bullet;': '\u2022',
    'bump;': '\u224E',
    'bumpE;': '\u2AAE',
    'bumpe;': '\u224F',
    'Bumpeq;': '\u224E',
    'bumpeq;': '\u224F',
    'Cacute;': '\u0106',
    'cacute;': '\u0107',
    'Cap;': '\u22D2',
    'cap;': '\u2229',
    'capand;': '\u2A44',
    'capbrcup;': '\u2A49',
    'capcap;': '\u2A4B',
    'capcup;': '\u2A47',
    'capdot;': '\u2A40',
    'CapitalDifferentialD;': '\u2145',
    'caps;': '\u2229\uFE00',
    'caret;': '\u2041',
    'caron;': '\u02C7',
    'Cayleys;': '\u212D',
    'ccaps;': '\u2A4D',
    'Ccaron;': '\u010C',
    'ccaron;': '\u010D',
    'Ccedil;': '\u00C7',
    'Ccedil': '\u00C7',
    'ccedil;': '\u00E7',
    'ccedil': '\u00E7',
    'Ccirc;': '\u0108',
    'ccirc;': '\u0109',
    'Cconint;': '\u2230',
    'ccups;': '\u2A4C',
    'ccupssm;': '\u2A50',
    'Cdot;': '\u010A',
    'cdot;': '\u010B',
    'cedil;': '\u00B8',
    'cedil': '\u00B8',
    'Cedilla;': '\u00B8',
    'cemptyv;': '\u29B2',
    'cent;': '\u00A2',
    'cent': '\u00A2',
    'CenterDot;': '\u00B7',
    'centerdot;': '\u00B7',
    'Cfr;': '\u212D',
    'cfr;': '\uD835\uDD20',
    'CHcy;': '\u0427',
    'chcy;': '\u0447',
    'check;': '\u2713',
    'checkmark;': '\u2713',
    'Chi;': '\u03A7',
    'chi;': '\u03C7',
    'cir;': '\u25CB',
    'circ;': '\u02C6',
    'circeq;': '\u2257',
    'circlearrowleft;': '\u21BA',
    'circlearrowright;': '\u21BB',
    'circledast;': '\u229B',
    'circledcirc;': '\u229A',
    'circleddash;': '\u229D',
    'CircleDot;': '\u2299',
    'circledR;': '\u00AE',
    'circledS;': '\u24C8',
    'CircleMinus;': '\u2296',
    'CirclePlus;': '\u2295',
    'CircleTimes;': '\u2297',
    'cirE;': '\u29C3',
    'cire;': '\u2257',
    'cirfnint;': '\u2A10',
    'cirmid;': '\u2AEF',
    'cirscir;': '\u29C2',
    'ClockwiseContourIntegral;': '\u2232',
    'CloseCurlyDoubleQuote;': '\u201D',
    'CloseCurlyQuote;': '\u2019',
    'clubs;': '\u2663',
    'clubsuit;': '\u2663',
    'Colon;': '\u2237',
    'colon;': '\u003A',
    'Colone;': '\u2A74',
    'colone;': '\u2254',
    'coloneq;': '\u2254',
    'comma;': '\u002C',
    'commat;': '\u0040',
    'comp;': '\u2201',
    'compfn;': '\u2218',
    'complement;': '\u2201',
    'complexes;': '\u2102',
    'cong;': '\u2245',
    'congdot;': '\u2A6D',
    'Congruent;': '\u2261',
    'Conint;': '\u222F',
    'conint;': '\u222E',
    'ContourIntegral;': '\u222E',
    'Copf;': '\u2102',
    'copf;': '\uD835\uDD54',
    'coprod;': '\u2210',
    'Coproduct;': '\u2210',
    'COPY;': '\u00A9',
    'COPY': '\u00A9',
    'copy;': '\u00A9',
    'copy': '\u00A9',
    'copysr;': '\u2117',
    'CounterClockwiseContourIntegral;': '\u2233',
    'crarr;': '\u21B5',
    'Cross;': '\u2A2F',
    'cross;': '\u2717',
    'Cscr;': '\uD835\uDC9E',
    'cscr;': '\uD835\uDCB8',
    'csub;': '\u2ACF',
    'csube;': '\u2AD1',
    'csup;': '\u2AD0',
    'csupe;': '\u2AD2',
    'ctdot;': '\u22EF',
    'cudarrl;': '\u2938',
    'cudarrr;': '\u2935',
    'cuepr;': '\u22DE',
    'cuesc;': '\u22DF',
    'cularr;': '\u21B6',
    'cularrp;': '\u293D',
    'Cup;': '\u22D3',
    'cup;': '\u222A',
    'cupbrcap;': '\u2A48',
    'CupCap;': '\u224D',
    'cupcap;': '\u2A46',
    'cupcup;': '\u2A4A',
    'cupdot;': '\u228D',
    'cupor;': '\u2A45',
    'cups;': '\u222A\uFE00',
    'curarr;': '\u21B7',
    'curarrm;': '\u293C',
    'curlyeqprec;': '\u22DE',
    'curlyeqsucc;': '\u22DF',
    'curlyvee;': '\u22CE',
    'curlywedge;': '\u22CF',
    'curren;': '\u00A4',
    'curren': '\u00A4',
    'curvearrowleft;': '\u21B6',
    'curvearrowright;': '\u21B7',
    'cuvee;': '\u22CE',
    'cuwed;': '\u22CF',
    'cwconint;': '\u2232',
    'cwint;': '\u2231',
    'cylcty;': '\u232D',
    'Dagger;': '\u2021',
    'dagger;': '\u2020',
    'daleth;': '\u2138',
    'Darr;': '\u21A1',
    'dArr;': '\u21D3',
    'darr;': '\u2193',
    'dash;': '\u2010',
    'Dashv;': '\u2AE4',
    'dashv;': '\u22A3',
    'dbkarow;': '\u290F',
    'dblac;': '\u02DD',
    'Dcaron;': '\u010E',
    'dcaron;': '\u010F',
    'Dcy;': '\u0414',
    'dcy;': '\u0434',
    'DD;': '\u2145',
    'dd;': '\u2146',
    'ddagger;': '\u2021',
    'ddarr;': '\u21CA',
    'DDotrahd;': '\u2911',
    'ddotseq;': '\u2A77',
    'deg;': '\u00B0',
    'deg': '\u00B0',
    'Del;': '\u2207',
    'Delta;': '\u0394',
    'delta;': '\u03B4',
    'demptyv;': '\u29B1',
    'dfisht;': '\u297F',
    'Dfr;': '\uD835\uDD07',
    'dfr;': '\uD835\uDD21',
    'dHar;': '\u2965',
    'dharl;': '\u21C3',
    'dharr;': '\u21C2',
    'DiacriticalAcute;': '\u00B4',
    'DiacriticalDot;': '\u02D9',
    'DiacriticalDoubleAcute;': '\u02DD',
    'DiacriticalGrave;': '\u0060',
    'DiacriticalTilde;': '\u02DC',
    'diam;': '\u22C4',
    'Diamond;': '\u22C4',
    'diamond;': '\u22C4',
    'diamondsuit;': '\u2666',
    'diams;': '\u2666',
    'die;': '\u00A8',
    'DifferentialD;': '\u2146',
    'digamma;': '\u03DD',
    'disin;': '\u22F2',
    'div;': '\u00F7',
    'divide;': '\u00F7',
    'divide': '\u00F7',
    'divideontimes;': '\u22C7',
    'divonx;': '\u22C7',
    'DJcy;': '\u0402',
    'djcy;': '\u0452',
    'dlcorn;': '\u231E',
    'dlcrop;': '\u230D',
    'dollar;': '\u0024',
    'Dopf;': '\uD835\uDD3B',
    'dopf;': '\uD835\uDD55',
    'Dot;': '\u00A8',
    'dot;': '\u02D9',
    'DotDot;': '\u20DC',
    'doteq;': '\u2250',
    'doteqdot;': '\u2251',
    'DotEqual;': '\u2250',
    'dotminus;': '\u2238',
    'dotplus;': '\u2214',
    'dotsquare;': '\u22A1',
    'doublebarwedge;': '\u2306',
    'DoubleContourIntegral;': '\u222F',
    'DoubleDot;': '\u00A8',
    'DoubleDownArrow;': '\u21D3',
    'DoubleLeftArrow;': '\u21D0',
    'DoubleLeftRightArrow;': '\u21D4',
    'DoubleLeftTee;': '\u2AE4',
    'DoubleLongLeftArrow;': '\u27F8',
    'DoubleLongLeftRightArrow;': '\u27FA',
    'DoubleLongRightArrow;': '\u27F9',
    'DoubleRightArrow;': '\u21D2',
    'DoubleRightTee;': '\u22A8',
    'DoubleUpArrow;': '\u21D1',
    'DoubleUpDownArrow;': '\u21D5',
    'DoubleVerticalBar;': '\u2225',
    'DownArrow;': '\u2193',
    'Downarrow;': '\u21D3',
    'downarrow;': '\u2193',
    'DownArrowBar;': '\u2913',
    'DownArrowUpArrow;': '\u21F5',
    'DownBreve;': '\u0311',
    'downdownarrows;': '\u21CA',
    'downharpoonleft;': '\u21C3',
    'downharpoonright;': '\u21C2',
    'DownLeftRightVector;': '\u2950',
    'DownLeftTeeVector;': '\u295E',
    'DownLeftVector;': '\u21BD',
    'DownLeftVectorBar;': '\u2956',
    'DownRightTeeVector;': '\u295F',
    'DownRightVector;': '\u21C1',
    'DownRightVectorBar;': '\u2957',
    'DownTee;': '\u22A4',
    'DownTeeArrow;': '\u21A7',
    'drbkarow;': '\u2910',
    'drcorn;': '\u231F',
    'drcrop;': '\u230C',
    'Dscr;': '\uD835\uDC9F',
    'dscr;': '\uD835\uDCB9',
    'DScy;': '\u0405',
    'dscy;': '\u0455',
    'dsol;': '\u29F6',
    'Dstrok;': '\u0110',
    'dstrok;': '\u0111',
    'dtdot;': '\u22F1',
    'dtri;': '\u25BF',
    'dtrif;': '\u25BE',
    'duarr;': '\u21F5',
    'duhar;': '\u296F',
    'dwangle;': '\u29A6',
    'DZcy;': '\u040F',
    'dzcy;': '\u045F',
    'dzigrarr;': '\u27FF',
    'Eacute;': '\u00C9',
    'Eacute': '\u00C9',
    'eacute;': '\u00E9',
    'eacute': '\u00E9',
    'easter;': '\u2A6E',
    'Ecaron;': '\u011A',
    'ecaron;': '\u011B',
    'ecir;': '\u2256',
    'Ecirc;': '\u00CA',
    'Ecirc': '\u00CA',
    'ecirc;': '\u00EA',
    'ecirc': '\u00EA',
    'ecolon;': '\u2255',
    'Ecy;': '\u042D',
    'ecy;': '\u044D',
    'eDDot;': '\u2A77',
    'Edot;': '\u0116',
    'eDot;': '\u2251',
    'edot;': '\u0117',
    'ee;': '\u2147',
    'efDot;': '\u2252',
    'Efr;': '\uD835\uDD08',
    'efr;': '\uD835\uDD22',
    'eg;': '\u2A9A',
    'Egrave;': '\u00C8',
    'Egrave': '\u00C8',
    'egrave;': '\u00E8',
    'egrave': '\u00E8',
    'egs;': '\u2A96',
    'egsdot;': '\u2A98',
    'el;': '\u2A99',
    'Element;': '\u2208',
    'elinters;': '\u23E7',
    'ell;': '\u2113',
    'els;': '\u2A95',
    'elsdot;': '\u2A97',
    'Emacr;': '\u0112',
    'emacr;': '\u0113',
    'empty;': '\u2205',
    'emptyset;': '\u2205',
    'EmptySmallSquare;': '\u25FB',
    'emptyv;': '\u2205',
    'EmptyVerySmallSquare;': '\u25AB',
    'emsp;': '\u2003',
    'emsp13;': '\u2004',
    'emsp14;': '\u2005',
    'ENG;': '\u014A',
    'eng;': '\u014B',
    'ensp;': '\u2002',
    'Eogon;': '\u0118',
    'eogon;': '\u0119',
    'Eopf;': '\uD835\uDD3C',
    'eopf;': '\uD835\uDD56',
    'epar;': '\u22D5',
    'eparsl;': '\u29E3',
    'eplus;': '\u2A71',
    'epsi;': '\u03B5',
    'Epsilon;': '\u0395',
    'epsilon;': '\u03B5',
    'epsiv;': '\u03F5',
    'eqcirc;': '\u2256',
    'eqcolon;': '\u2255',
    'eqsim;': '\u2242',
    'eqslantgtr;': '\u2A96',
    'eqslantless;': '\u2A95',
    'Equal;': '\u2A75',
    'equals;': '\u003D',
    'EqualTilde;': '\u2242',
    'equest;': '\u225F',
    'Equilibrium;': '\u21CC',
    'equiv;': '\u2261',
    'equivDD;': '\u2A78',
    'eqvparsl;': '\u29E5',
    'erarr;': '\u2971',
    'erDot;': '\u2253',
    'Escr;': '\u2130',
    'escr;': '\u212F',
    'esdot;': '\u2250',
    'Esim;': '\u2A73',
    'esim;': '\u2242',
    'Eta;': '\u0397',
    'eta;': '\u03B7',
    'ETH;': '\u00D0',
    'ETH': '\u00D0',
    'eth;': '\u00F0',
    'eth': '\u00F0',
    'Euml;': '\u00CB',
    'Euml': '\u00CB',
    'euml;': '\u00EB',
    'euml': '\u00EB',
    'euro;': '\u20AC',
    'excl;': '\u0021',
    'exist;': '\u2203',
    'Exists;': '\u2203',
    'expectation;': '\u2130',
    'ExponentialE;': '\u2147',
    'exponentiale;': '\u2147',
    'fallingdotseq;': '\u2252',
    'Fcy;': '\u0424',
    'fcy;': '\u0444',
    'female;': '\u2640',
    'ffilig;': '\uFB03',
    'fflig;': '\uFB00',
    'ffllig;': '\uFB04',
    'Ffr;': '\uD835\uDD09',
    'ffr;': '\uD835\uDD23',
    'filig;': '\uFB01',
    'FilledSmallSquare;': '\u25FC',
    'FilledVerySmallSquare;': '\u25AA',
    'fjlig;': '\u0066\u006A',
    'flat;': '\u266D',
    'fllig;': '\uFB02',
    'fltns;': '\u25B1',
    'fnof;': '\u0192',
    'Fopf;': '\uD835\uDD3D',
    'fopf;': '\uD835\uDD57',
    'ForAll;': '\u2200',
    'forall;': '\u2200',
    'fork;': '\u22D4',
    'forkv;': '\u2AD9',
    'Fouriertrf;': '\u2131',
    'fpartint;': '\u2A0D',
    'frac12;': '\u00BD',
    'frac12': '\u00BD',
    'frac13;': '\u2153',
    'frac14;': '\u00BC',
    'frac14': '\u00BC',
    'frac15;': '\u2155',
    'frac16;': '\u2159',
    'frac18;': '\u215B',
    'frac23;': '\u2154',
    'frac25;': '\u2156',
    'frac34;': '\u00BE',
    'frac34': '\u00BE',
    'frac35;': '\u2157',
    'frac38;': '\u215C',
    'frac45;': '\u2158',
    'frac56;': '\u215A',
    'frac58;': '\u215D',
    'frac78;': '\u215E',
    'frasl;': '\u2044',
    'frown;': '\u2322',
    'Fscr;': '\u2131',
    'fscr;': '\uD835\uDCBB',
    'gacute;': '\u01F5',
    'Gamma;': '\u0393',
    'gamma;': '\u03B3',
    'Gammad;': '\u03DC',
    'gammad;': '\u03DD',
    'gap;': '\u2A86',
    'Gbreve;': '\u011E',
    'gbreve;': '\u011F',
    'Gcedil;': '\u0122',
    'Gcirc;': '\u011C',
    'gcirc;': '\u011D',
    'Gcy;': '\u0413',
    'gcy;': '\u0433',
    'Gdot;': '\u0120',
    'gdot;': '\u0121',
    'gE;': '\u2267',
    'ge;': '\u2265',
    'gEl;': '\u2A8C',
    'gel;': '\u22DB',
    'geq;': '\u2265',
    'geqq;': '\u2267',
    'geqslant;': '\u2A7E',
    'ges;': '\u2A7E',
    'gescc;': '\u2AA9',
    'gesdot;': '\u2A80',
    'gesdoto;': '\u2A82',
    'gesdotol;': '\u2A84',
    'gesl;': '\u22DB\uFE00',
    'gesles;': '\u2A94',
    'Gfr;': '\uD835\uDD0A',
    'gfr;': '\uD835\uDD24',
    'Gg;': '\u22D9',
    'gg;': '\u226B',
    'ggg;': '\u22D9',
    'gimel;': '\u2137',
    'GJcy;': '\u0403',
    'gjcy;': '\u0453',
    'gl;': '\u2277',
    'gla;': '\u2AA5',
    'glE;': '\u2A92',
    'glj;': '\u2AA4',
    'gnap;': '\u2A8A',
    'gnapprox;': '\u2A8A',
    'gnE;': '\u2269',
    'gne;': '\u2A88',
    'gneq;': '\u2A88',
    'gneqq;': '\u2269',
    'gnsim;': '\u22E7',
    'Gopf;': '\uD835\uDD3E',
    'gopf;': '\uD835\uDD58',
    'grave;': '\u0060',
    'GreaterEqual;': '\u2265',
    'GreaterEqualLess;': '\u22DB',
    'GreaterFullEqual;': '\u2267',
    'GreaterGreater;': '\u2AA2',
    'GreaterLess;': '\u2277',
    'GreaterSlantEqual;': '\u2A7E',
    'GreaterTilde;': '\u2273',
    'Gscr;': '\uD835\uDCA2',
    'gscr;': '\u210A',
    'gsim;': '\u2273',
    'gsime;': '\u2A8E',
    'gsiml;': '\u2A90',
    'GT;': '\u003E',
    'GT': '\u003E',
    'Gt;': '\u226B',
    'gt;': '\u003E',
    'gt': '\u003E',
    'gtcc;': '\u2AA7',
    'gtcir;': '\u2A7A',
    'gtdot;': '\u22D7',
    'gtlPar;': '\u2995',
    'gtquest;': '\u2A7C',
    'gtrapprox;': '\u2A86',
    'gtrarr;': '\u2978',
    'gtrdot;': '\u22D7',
    'gtreqless;': '\u22DB',
    'gtreqqless;': '\u2A8C',
    'gtrless;': '\u2277',
    'gtrsim;': '\u2273',
    'gvertneqq;': '\u2269\uFE00',
    'gvnE;': '\u2269\uFE00',
    'Hacek;': '\u02C7',
    'hairsp;': '\u200A',
    'half;': '\u00BD',
    'hamilt;': '\u210B',
    'HARDcy;': '\u042A',
    'hardcy;': '\u044A',
    'hArr;': '\u21D4',
    'harr;': '\u2194',
    'harrcir;': '\u2948',
    'harrw;': '\u21AD',
    'Hat;': '\u005E',
    'hbar;': '\u210F',
    'Hcirc;': '\u0124',
    'hcirc;': '\u0125',
    'hearts;': '\u2665',
    'heartsuit;': '\u2665',
    'hellip;': '\u2026',
    'hercon;': '\u22B9',
    'Hfr;': '\u210C',
    'hfr;': '\uD835\uDD25',
    'HilbertSpace;': '\u210B',
    'hksearow;': '\u2925',
    'hkswarow;': '\u2926',
    'hoarr;': '\u21FF',
    'homtht;': '\u223B',
    'hookleftarrow;': '\u21A9',
    'hookrightarrow;': '\u21AA',
    'Hopf;': '\u210D',
    'hopf;': '\uD835\uDD59',
    'horbar;': '\u2015',
    'HorizontalLine;': '\u2500',
    'Hscr;': '\u210B',
    'hscr;': '\uD835\uDCBD',
    'hslash;': '\u210F',
    'Hstrok;': '\u0126',
    'hstrok;': '\u0127',
    'HumpDownHump;': '\u224E',
    'HumpEqual;': '\u224F',
    'hybull;': '\u2043',
    'hyphen;': '\u2010',
    'Iacute;': '\u00CD',
    'Iacute': '\u00CD',
    'iacute;': '\u00ED',
    'iacute': '\u00ED',
    'ic;': '\u2063',
    'Icirc;': '\u00CE',
    'Icirc': '\u00CE',
    'icirc;': '\u00EE',
    'icirc': '\u00EE',
    'Icy;': '\u0418',
    'icy;': '\u0438',
    'Idot;': '\u0130',
    'IEcy;': '\u0415',
    'iecy;': '\u0435',
    'iexcl;': '\u00A1',
    'iexcl': '\u00A1',
    'iff;': '\u21D4',
    'Ifr;': '\u2111',
    'ifr;': '\uD835\uDD26',
    'Igrave;': '\u00CC',
    'Igrave': '\u00CC',
    'igrave;': '\u00EC',
    'igrave': '\u00EC',
    'ii;': '\u2148',
    'iiiint;': '\u2A0C',
    'iiint;': '\u222D',
    'iinfin;': '\u29DC',
    'iiota;': '\u2129',
    'IJlig;': '\u0132',
    'ijlig;': '\u0133',
    'Im;': '\u2111',
    'Imacr;': '\u012A',
    'imacr;': '\u012B',
    'image;': '\u2111',
    'ImaginaryI;': '\u2148',
    'imagline;': '\u2110',
    'imagpart;': '\u2111',
    'imath;': '\u0131',
    'imof;': '\u22B7',
    'imped;': '\u01B5',
    'Implies;': '\u21D2',
    'in;': '\u2208',
    'incare;': '\u2105',
    'infin;': '\u221E',
    'infintie;': '\u29DD',
    'inodot;': '\u0131',
    'Int;': '\u222C',
    'int;': '\u222B',
    'intcal;': '\u22BA',
    'integers;': '\u2124',
    'Integral;': '\u222B',
    'intercal;': '\u22BA',
    'Intersection;': '\u22C2',
    'intlarhk;': '\u2A17',
    'intprod;': '\u2A3C',
    'InvisibleComma;': '\u2063',
    'InvisibleTimes;': '\u2062',
    'IOcy;': '\u0401',
    'iocy;': '\u0451',
    'Iogon;': '\u012E',
    'iogon;': '\u012F',
    'Iopf;': '\uD835\uDD40',
    'iopf;': '\uD835\uDD5A',
    'Iota;': '\u0399',
    'iota;': '\u03B9',
    'iprod;': '\u2A3C',
    'iquest;': '\u00BF',
    'iquest': '\u00BF',
    'Iscr;': '\u2110',
    'iscr;': '\uD835\uDCBE',
    'isin;': '\u2208',
    'isindot;': '\u22F5',
    'isinE;': '\u22F9',
    'isins;': '\u22F4',
    'isinsv;': '\u22F3',
    'isinv;': '\u2208',
    'it;': '\u2062',
    'Itilde;': '\u0128',
    'itilde;': '\u0129',
    'Iukcy;': '\u0406',
    'iukcy;': '\u0456',
    'Iuml;': '\u00CF',
    'Iuml': '\u00CF',
    'iuml;': '\u00EF',
    'iuml': '\u00EF',
    'Jcirc;': '\u0134',
    'jcirc;': '\u0135',
    'Jcy;': '\u0419',
    'jcy;': '\u0439',
    'Jfr;': '\uD835\uDD0D',
    'jfr;': '\uD835\uDD27',
    'jmath;': '\u0237',
    'Jopf;': '\uD835\uDD41',
    'jopf;': '\uD835\uDD5B',
    'Jscr;': '\uD835\uDCA5',
    'jscr;': '\uD835\uDCBF',
    'Jsercy;': '\u0408',
    'jsercy;': '\u0458',
    'Jukcy;': '\u0404',
    'jukcy;': '\u0454',
    'Kappa;': '\u039A',
    'kappa;': '\u03BA',
    'kappav;': '\u03F0',
    'Kcedil;': '\u0136',
    'kcedil;': '\u0137',
    'Kcy;': '\u041A',
    'kcy;': '\u043A',
    'Kfr;': '\uD835\uDD0E',
    'kfr;': '\uD835\uDD28',
    'kgreen;': '\u0138',
    'KHcy;': '\u0425',
    'khcy;': '\u0445',
    'KJcy;': '\u040C',
    'kjcy;': '\u045C',
    'Kopf;': '\uD835\uDD42',
    'kopf;': '\uD835\uDD5C',
    'Kscr;': '\uD835\uDCA6',
    'kscr;': '\uD835\uDCC0',
    'lAarr;': '\u21DA',
    'Lacute;': '\u0139',
    'lacute;': '\u013A',
    'laemptyv;': '\u29B4',
    'lagran;': '\u2112',
    'Lambda;': '\u039B',
    'lambda;': '\u03BB',
    'Lang;': '\u27EA',
    'lang;': '\u27E8',
    'langd;': '\u2991',
    'langle;': '\u27E8',
    'lap;': '\u2A85',
    'Laplacetrf;': '\u2112',
    'laquo;': '\u00AB',
    'laquo': '\u00AB',
    'Larr;': '\u219E',
    'lArr;': '\u21D0',
    'larr;': '\u2190',
    'larrb;': '\u21E4',
    'larrbfs;': '\u291F',
    'larrfs;': '\u291D',
    'larrhk;': '\u21A9',
    'larrlp;': '\u21AB',
    'larrpl;': '\u2939',
    'larrsim;': '\u2973',
    'larrtl;': '\u21A2',
    'lat;': '\u2AAB',
    'lAtail;': '\u291B',
    'latail;': '\u2919',
    'late;': '\u2AAD',
    'lates;': '\u2AAD\uFE00',
    'lBarr;': '\u290E',
    'lbarr;': '\u290C',
    'lbbrk;': '\u2772',
    'lbrace;': '\u007B',
    'lbrack;': '\u005B',
    'lbrke;': '\u298B',
    'lbrksld;': '\u298F',
    'lbrkslu;': '\u298D',
    'Lcaron;': '\u013D',
    'lcaron;': '\u013E',
    'Lcedil;': '\u013B',
    'lcedil;': '\u013C',
    'lceil;': '\u2308',
    'lcub;': '\u007B',
    'Lcy;': '\u041B',
    'lcy;': '\u043B',
    'ldca;': '\u2936',
    'ldquo;': '\u201C',
    'ldquor;': '\u201E',
    'ldrdhar;': '\u2967',
    'ldrushar;': '\u294B',
    'ldsh;': '\u21B2',
    'lE;': '\u2266',
    'le;': '\u2264',
    'LeftAngleBracket;': '\u27E8',
    'LeftArrow;': '\u2190',
    'Leftarrow;': '\u21D0',
    'leftarrow;': '\u2190',
    'LeftArrowBar;': '\u21E4',
    'LeftArrowRightArrow;': '\u21C6',
    'leftarrowtail;': '\u21A2',
    'LeftCeiling;': '\u2308',
    'LeftDoubleBracket;': '\u27E6',
    'LeftDownTeeVector;': '\u2961',
    'LeftDownVector;': '\u21C3',
    'LeftDownVectorBar;': '\u2959',
    'LeftFloor;': '\u230A',
    'leftharpoondown;': '\u21BD',
    'leftharpoonup;': '\u21BC',
    'leftleftarrows;': '\u21C7',
    'LeftRightArrow;': '\u2194',
    'Leftrightarrow;': '\u21D4',
    'leftrightarrow;': '\u2194',
    'leftrightarrows;': '\u21C6',
    'leftrightharpoons;': '\u21CB',
    'leftrightsquigarrow;': '\u21AD',
    'LeftRightVector;': '\u294E',
    'LeftTee;': '\u22A3',
    'LeftTeeArrow;': '\u21A4',
    'LeftTeeVector;': '\u295A',
    'leftthreetimes;': '\u22CB',
    'LeftTriangle;': '\u22B2',
    'LeftTriangleBar;': '\u29CF',
    'LeftTriangleEqual;': '\u22B4',
    'LeftUpDownVector;': '\u2951',
    'LeftUpTeeVector;': '\u2960',
    'LeftUpVector;': '\u21BF',
    'LeftUpVectorBar;': '\u2958',
    'LeftVector;': '\u21BC',
    'LeftVectorBar;': '\u2952',
    'lEg;': '\u2A8B',
    'leg;': '\u22DA',
    'leq;': '\u2264',
    'leqq;': '\u2266',
    'leqslant;': '\u2A7D',
    'les;': '\u2A7D',
    'lescc;': '\u2AA8',
    'lesdot;': '\u2A7F',
    'lesdoto;': '\u2A81',
    'lesdotor;': '\u2A83',
    'lesg;': '\u22DA\uFE00',
    'lesges;': '\u2A93',
    'lessapprox;': '\u2A85',
    'lessdot;': '\u22D6',
    'lesseqgtr;': '\u22DA',
    'lesseqqgtr;': '\u2A8B',
    'LessEqualGreater;': '\u22DA',
    'LessFullEqual;': '\u2266',
    'LessGreater;': '\u2276',
    'lessgtr;': '\u2276',
    'LessLess;': '\u2AA1',
    'lesssim;': '\u2272',
    'LessSlantEqual;': '\u2A7D',
    'LessTilde;': '\u2272',
    'lfisht;': '\u297C',
    'lfloor;': '\u230A',
    'Lfr;': '\uD835\uDD0F',
    'lfr;': '\uD835\uDD29',
    'lg;': '\u2276',
    'lgE;': '\u2A91',
    'lHar;': '\u2962',
    'lhard;': '\u21BD',
    'lharu;': '\u21BC',
    'lharul;': '\u296A',
    'lhblk;': '\u2584',
    'LJcy;': '\u0409',
    'ljcy;': '\u0459',
    'Ll;': '\u22D8',
    'll;': '\u226A',
    'llarr;': '\u21C7',
    'llcorner;': '\u231E',
    'Lleftarrow;': '\u21DA',
    'llhard;': '\u296B',
    'lltri;': '\u25FA',
    'Lmidot;': '\u013F',
    'lmidot;': '\u0140',
    'lmoust;': '\u23B0',
    'lmoustache;': '\u23B0',
    'lnap;': '\u2A89',
    'lnapprox;': '\u2A89',
    'lnE;': '\u2268',
    'lne;': '\u2A87',
    'lneq;': '\u2A87',
    'lneqq;': '\u2268',
    'lnsim;': '\u22E6',
    'loang;': '\u27EC',
    'loarr;': '\u21FD',
    'lobrk;': '\u27E6',
    'LongLeftArrow;': '\u27F5',
    'Longleftarrow;': '\u27F8',
    'longleftarrow;': '\u27F5',
    'LongLeftRightArrow;': '\u27F7',
    'Longleftrightarrow;': '\u27FA',
    'longleftrightarrow;': '\u27F7',
    'longmapsto;': '\u27FC',
    'LongRightArrow;': '\u27F6',
    'Longrightarrow;': '\u27F9',
    'longrightarrow;': '\u27F6',
    'looparrowleft;': '\u21AB',
    'looparrowright;': '\u21AC',
    'lopar;': '\u2985',
    'Lopf;': '\uD835\uDD43',
    'lopf;': '\uD835\uDD5D',
    'loplus;': '\u2A2D',
    'lotimes;': '\u2A34',
    'lowast;': '\u2217',
    'lowbar;': '\u005F',
    'LowerLeftArrow;': '\u2199',
    'LowerRightArrow;': '\u2198',
    'loz;': '\u25CA',
    'lozenge;': '\u25CA',
    'lozf;': '\u29EB',
    'lpar;': '\u0028',
    'lparlt;': '\u2993',
    'lrarr;': '\u21C6',
    'lrcorner;': '\u231F',
    'lrhar;': '\u21CB',
    'lrhard;': '\u296D',
    'lrm;': '\u200E',
    'lrtri;': '\u22BF',
    'lsaquo;': '\u2039',
    'Lscr;': '\u2112',
    'lscr;': '\uD835\uDCC1',
    'Lsh;': '\u21B0',
    'lsh;': '\u21B0',
    'lsim;': '\u2272',
    'lsime;': '\u2A8D',
    'lsimg;': '\u2A8F',
    'lsqb;': '\u005B',
    'lsquo;': '\u2018',
    'lsquor;': '\u201A',
    'Lstrok;': '\u0141',
    'lstrok;': '\u0142',
    'LT;': '\u003C',
    'LT': '\u003C',
    'Lt;': '\u226A',
    'lt;': '\u003C',
    'lt': '\u003C',
    'ltcc;': '\u2AA6',
    'ltcir;': '\u2A79',
    'ltdot;': '\u22D6',
    'lthree;': '\u22CB',
    'ltimes;': '\u22C9',
    'ltlarr;': '\u2976',
    'ltquest;': '\u2A7B',
    'ltri;': '\u25C3',
    'ltrie;': '\u22B4',
    'ltrif;': '\u25C2',
    'ltrPar;': '\u2996',
    'lurdshar;': '\u294A',
    'luruhar;': '\u2966',
    'lvertneqq;': '\u2268\uFE00',
    'lvnE;': '\u2268\uFE00',
    'macr;': '\u00AF',
    'macr': '\u00AF',
    'male;': '\u2642',
    'malt;': '\u2720',
    'maltese;': '\u2720',
    'Map;': '\u2905',
    'map;': '\u21A6',
    'mapsto;': '\u21A6',
    'mapstodown;': '\u21A7',
    'mapstoleft;': '\u21A4',
    'mapstoup;': '\u21A5',
    'marker;': '\u25AE',
    'mcomma;': '\u2A29',
    'Mcy;': '\u041C',
    'mcy;': '\u043C',
    'mdash;': '\u2014',
    'mDDot;': '\u223A',
    'measuredangle;': '\u2221',
    'MediumSpace;': '\u205F',
    'Mellintrf;': '\u2133',
    'Mfr;': '\uD835\uDD10',
    'mfr;': '\uD835\uDD2A',
    'mho;': '\u2127',
    'micro;': '\u00B5',
    'micro': '\u00B5',
    'mid;': '\u2223',
    'midast;': '\u002A',
    'midcir;': '\u2AF0',
    'middot;': '\u00B7',
    'middot': '\u00B7',
    'minus;': '\u2212',
    'minusb;': '\u229F',
    'minusd;': '\u2238',
    'minusdu;': '\u2A2A',
    'MinusPlus;': '\u2213',
    'mlcp;': '\u2ADB',
    'mldr;': '\u2026',
    'mnplus;': '\u2213',
    'models;': '\u22A7',
    'Mopf;': '\uD835\uDD44',
    'mopf;': '\uD835\uDD5E',
    'mp;': '\u2213',
    'Mscr;': '\u2133',
    'mscr;': '\uD835\uDCC2',
    'mstpos;': '\u223E',
    'Mu;': '\u039C',
    'mu;': '\u03BC',
    'multimap;': '\u22B8',
    'mumap;': '\u22B8',
    'nabla;': '\u2207',
    'Nacute;': '\u0143',
    'nacute;': '\u0144',
    'nang;': '\u2220\u20D2',
    'nap;': '\u2249',
    'napE;': '\u2A70\u0338',
    'napid;': '\u224B\u0338',
    'napos;': '\u0149',
    'napprox;': '\u2249',
    'natur;': '\u266E',
    'natural;': '\u266E',
    'naturals;': '\u2115',
    'nbsp;': '\u00A0',
    'nbsp': '\u00A0',
    'nbump;': '\u224E\u0338',
    'nbumpe;': '\u224F\u0338',
    'ncap;': '\u2A43',
    'Ncaron;': '\u0147',
    'ncaron;': '\u0148',
    'Ncedil;': '\u0145',
    'ncedil;': '\u0146',
    'ncong;': '\u2247',
    'ncongdot;': '\u2A6D\u0338',
    'ncup;': '\u2A42',
    'Ncy;': '\u041D',
    'ncy;': '\u043D',
    'ndash;': '\u2013',
    'ne;': '\u2260',
    'nearhk;': '\u2924',
    'neArr;': '\u21D7',
    'nearr;': '\u2197',
    'nearrow;': '\u2197',
    'nedot;': '\u2250\u0338',
    'NegativeMediumSpace;': '\u200B',
    'NegativeThickSpace;': '\u200B',
    'NegativeThinSpace;': '\u200B',
    'NegativeVeryThinSpace;': '\u200B',
    'nequiv;': '\u2262',
    'nesear;': '\u2928',
    'nesim;': '\u2242\u0338',
    'NestedGreaterGreater;': '\u226B',
    'NestedLessLess;': '\u226A',
    'NewLine;': '\u000A',
    'nexist;': '\u2204',
    'nexists;': '\u2204',
    'Nfr;': '\uD835\uDD11',
    'nfr;': '\uD835\uDD2B',
    'ngE;': '\u2267\u0338',
    'nge;': '\u2271',
    'ngeq;': '\u2271',
    'ngeqq;': '\u2267\u0338',
    'ngeqslant;': '\u2A7E\u0338',
    'nges;': '\u2A7E\u0338',
    'nGg;': '\u22D9\u0338',
    'ngsim;': '\u2275',
    'nGt;': '\u226B\u20D2',
    'ngt;': '\u226F',
    'ngtr;': '\u226F',
    'nGtv;': '\u226B\u0338',
    'nhArr;': '\u21CE',
    'nharr;': '\u21AE',
    'nhpar;': '\u2AF2',
    'ni;': '\u220B',
    'nis;': '\u22FC',
    'nisd;': '\u22FA',
    'niv;': '\u220B',
    'NJcy;': '\u040A',
    'njcy;': '\u045A',
    'nlArr;': '\u21CD',
    'nlarr;': '\u219A',
    'nldr;': '\u2025',
    'nlE;': '\u2266\u0338',
    'nle;': '\u2270',
    'nLeftarrow;': '\u21CD',
    'nleftarrow;': '\u219A',
    'nLeftrightarrow;': '\u21CE',
    'nleftrightarrow;': '\u21AE',
    'nleq;': '\u2270',
    'nleqq;': '\u2266\u0338',
    'nleqslant;': '\u2A7D\u0338',
    'nles;': '\u2A7D\u0338',
    'nless;': '\u226E',
    'nLl;': '\u22D8\u0338',
    'nlsim;': '\u2274',
    'nLt;': '\u226A\u20D2',
    'nlt;': '\u226E',
    'nltri;': '\u22EA',
    'nltrie;': '\u22EC',
    'nLtv;': '\u226A\u0338',
    'nmid;': '\u2224',
    'NoBreak;': '\u2060',
    'NonBreakingSpace;': '\u00A0',
    'Nopf;': '\u2115',
    'nopf;': '\uD835\uDD5F',
    'Not;': '\u2AEC',
    'not;': '\u00AC',
    'not': '\u00AC',
    'NotCongruent;': '\u2262',
    'NotCupCap;': '\u226D',
    'NotDoubleVerticalBar;': '\u2226',
    'NotElement;': '\u2209',
    'NotEqual;': '\u2260',
    'NotEqualTilde;': '\u2242\u0338',
    'NotExists;': '\u2204',
    'NotGreater;': '\u226F',
    'NotGreaterEqual;': '\u2271',
    'NotGreaterFullEqual;': '\u2267\u0338',
    'NotGreaterGreater;': '\u226B\u0338',
    'NotGreaterLess;': '\u2279',
    'NotGreaterSlantEqual;': '\u2A7E\u0338',
    'NotGreaterTilde;': '\u2275',
    'NotHumpDownHump;': '\u224E\u0338',
    'NotHumpEqual;': '\u224F\u0338',
    'notin;': '\u2209',
    'notindot;': '\u22F5\u0338',
    'notinE;': '\u22F9\u0338',
    'notinva;': '\u2209',
    'notinvb;': '\u22F7',
    'notinvc;': '\u22F6',
    'NotLeftTriangle;': '\u22EA',
    'NotLeftTriangleBar;': '\u29CF\u0338',
    'NotLeftTriangleEqual;': '\u22EC',
    'NotLess;': '\u226E',
    'NotLessEqual;': '\u2270',
    'NotLessGreater;': '\u2278',
    'NotLessLess;': '\u226A\u0338',
    'NotLessSlantEqual;': '\u2A7D\u0338',
    'NotLessTilde;': '\u2274',
    'NotNestedGreaterGreater;': '\u2AA2\u0338',
    'NotNestedLessLess;': '\u2AA1\u0338',
    'notni;': '\u220C',
    'notniva;': '\u220C',
    'notnivb;': '\u22FE',
    'notnivc;': '\u22FD',
    'NotPrecedes;': '\u2280',
    'NotPrecedesEqual;': '\u2AAF\u0338',
    'NotPrecedesSlantEqual;': '\u22E0',
    'NotReverseElement;': '\u220C',
    'NotRightTriangle;': '\u22EB',
    'NotRightTriangleBar;': '\u29D0\u0338',
    'NotRightTriangleEqual;': '\u22ED',
    'NotSquareSubset;': '\u228F\u0338',
    'NotSquareSubsetEqual;': '\u22E2',
    'NotSquareSuperset;': '\u2290\u0338',
    'NotSquareSupersetEqual;': '\u22E3',
    'NotSubset;': '\u2282\u20D2',
    'NotSubsetEqual;': '\u2288',
    'NotSucceeds;': '\u2281',
    'NotSucceedsEqual;': '\u2AB0\u0338',
    'NotSucceedsSlantEqual;': '\u22E1',
    'NotSucceedsTilde;': '\u227F\u0338',
    'NotSuperset;': '\u2283\u20D2',
    'NotSupersetEqual;': '\u2289',
    'NotTilde;': '\u2241',
    'NotTildeEqual;': '\u2244',
    'NotTildeFullEqual;': '\u2247',
    'NotTildeTilde;': '\u2249',
    'NotVerticalBar;': '\u2224',
    'npar;': '\u2226',
    'nparallel;': '\u2226',
    'nparsl;': '\u2AFD\u20E5',
    'npart;': '\u2202\u0338',
    'npolint;': '\u2A14',
    'npr;': '\u2280',
    'nprcue;': '\u22E0',
    'npre;': '\u2AAF\u0338',
    'nprec;': '\u2280',
    'npreceq;': '\u2AAF\u0338',
    'nrArr;': '\u21CF',
    'nrarr;': '\u219B',
    'nrarrc;': '\u2933\u0338',
    'nrarrw;': '\u219D\u0338',
    'nRightarrow;': '\u21CF',
    'nrightarrow;': '\u219B',
    'nrtri;': '\u22EB',
    'nrtrie;': '\u22ED',
    'nsc;': '\u2281',
    'nsccue;': '\u22E1',
    'nsce;': '\u2AB0\u0338',
    'Nscr;': '\uD835\uDCA9',
    'nscr;': '\uD835\uDCC3',
    'nshortmid;': '\u2224',
    'nshortparallel;': '\u2226',
    'nsim;': '\u2241',
    'nsime;': '\u2244',
    'nsimeq;': '\u2244',
    'nsmid;': '\u2224',
    'nspar;': '\u2226',
    'nsqsube;': '\u22E2',
    'nsqsupe;': '\u22E3',
    'nsub;': '\u2284',
    'nsubE;': '\u2AC5\u0338',
    'nsube;': '\u2288',
    'nsubset;': '\u2282\u20D2',
    'nsubseteq;': '\u2288',
    'nsubseteqq;': '\u2AC5\u0338',
    'nsucc;': '\u2281',
    'nsucceq;': '\u2AB0\u0338',
    'nsup;': '\u2285',
    'nsupE;': '\u2AC6\u0338',
    'nsupe;': '\u2289',
    'nsupset;': '\u2283\u20D2',
    'nsupseteq;': '\u2289',
    'nsupseteqq;': '\u2AC6\u0338',
    'ntgl;': '\u2279',
    'Ntilde;': '\u00D1',
    'Ntilde': '\u00D1',
    'ntilde;': '\u00F1',
    'ntilde': '\u00F1',
    'ntlg;': '\u2278',
    'ntriangleleft;': '\u22EA',
    'ntrianglelefteq;': '\u22EC',
    'ntriangleright;': '\u22EB',
    'ntrianglerighteq;': '\u22ED',
    'Nu;': '\u039D',
    'nu;': '\u03BD',
    'num;': '\u0023',
    'numero;': '\u2116',
    'numsp;': '\u2007',
    'nvap;': '\u224D\u20D2',
    'nVDash;': '\u22AF',
    'nVdash;': '\u22AE',
    'nvDash;': '\u22AD',
    'nvdash;': '\u22AC',
    'nvge;': '\u2265\u20D2',
    'nvgt;': '\u003E\u20D2',
    'nvHarr;': '\u2904',
    'nvinfin;': '\u29DE',
    'nvlArr;': '\u2902',
    'nvle;': '\u2264\u20D2',
    'nvlt;': '\u003C\u20D2',
    'nvltrie;': '\u22B4\u20D2',
    'nvrArr;': '\u2903',
    'nvrtrie;': '\u22B5\u20D2',
    'nvsim;': '\u223C\u20D2',
    'nwarhk;': '\u2923',
    'nwArr;': '\u21D6',
    'nwarr;': '\u2196',
    'nwarrow;': '\u2196',
    'nwnear;': '\u2927',
    'Oacute;': '\u00D3',
    'Oacute': '\u00D3',
    'oacute;': '\u00F3',
    'oacute': '\u00F3',
    'oast;': '\u229B',
    'ocir;': '\u229A',
    'Ocirc;': '\u00D4',
    'Ocirc': '\u00D4',
    'ocirc;': '\u00F4',
    'ocirc': '\u00F4',
    'Ocy;': '\u041E',
    'ocy;': '\u043E',
    'odash;': '\u229D',
    'Odblac;': '\u0150',
    'odblac;': '\u0151',
    'odiv;': '\u2A38',
    'odot;': '\u2299',
    'odsold;': '\u29BC',
    'OElig;': '\u0152',
    'oelig;': '\u0153',
    'ofcir;': '\u29BF',
    'Ofr;': '\uD835\uDD12',
    'ofr;': '\uD835\uDD2C',
    'ogon;': '\u02DB',
    'Ograve;': '\u00D2',
    'Ograve': '\u00D2',
    'ograve;': '\u00F2',
    'ograve': '\u00F2',
    'ogt;': '\u29C1',
    'ohbar;': '\u29B5',
    'ohm;': '\u03A9',
    'oint;': '\u222E',
    'olarr;': '\u21BA',
    'olcir;': '\u29BE',
    'olcross;': '\u29BB',
    'oline;': '\u203E',
    'olt;': '\u29C0',
    'Omacr;': '\u014C',
    'omacr;': '\u014D',
    'Omega;': '\u03A9',
    'omega;': '\u03C9',
    'Omicron;': '\u039F',
    'omicron;': '\u03BF',
    'omid;': '\u29B6',
    'ominus;': '\u2296',
    'Oopf;': '\uD835\uDD46',
    'oopf;': '\uD835\uDD60',
    'opar;': '\u29B7',
    'OpenCurlyDoubleQuote;': '\u201C',
    'OpenCurlyQuote;': '\u2018',
    'operp;': '\u29B9',
    'oplus;': '\u2295',
    'Or;': '\u2A54',
    'or;': '\u2228',
    'orarr;': '\u21BB',
    'ord;': '\u2A5D',
    'order;': '\u2134',
    'orderof;': '\u2134',
    'ordf;': '\u00AA',
    'ordf': '\u00AA',
    'ordm;': '\u00BA',
    'ordm': '\u00BA',
    'origof;': '\u22B6',
    'oror;': '\u2A56',
    'orslope;': '\u2A57',
    'orv;': '\u2A5B',
    'oS;': '\u24C8',
    'Oscr;': '\uD835\uDCAA',
    'oscr;': '\u2134',
    'Oslash;': '\u00D8',
    'Oslash': '\u00D8',
    'oslash;': '\u00F8',
    'oslash': '\u00F8',
    'osol;': '\u2298',
    'Otilde;': '\u00D5',
    'Otilde': '\u00D5',
    'otilde;': '\u00F5',
    'otilde': '\u00F5',
    'Otimes;': '\u2A37',
    'otimes;': '\u2297',
    'otimesas;': '\u2A36',
    'Ouml;': '\u00D6',
    'Ouml': '\u00D6',
    'ouml;': '\u00F6',
    'ouml': '\u00F6',
    'ovbar;': '\u233D',
    'OverBar;': '\u203E',
    'OverBrace;': '\u23DE',
    'OverBracket;': '\u23B4',
    'OverParenthesis;': '\u23DC',
    'par;': '\u2225',
    'para;': '\u00B6',
    'para': '\u00B6',
    'parallel;': '\u2225',
    'parsim;': '\u2AF3',
    'parsl;': '\u2AFD',
    'part;': '\u2202',
    'PartialD;': '\u2202',
    'Pcy;': '\u041F',
    'pcy;': '\u043F',
    'percnt;': '\u0025',
    'period;': '\u002E',
    'permil;': '\u2030',
    'perp;': '\u22A5',
    'pertenk;': '\u2031',
    'Pfr;': '\uD835\uDD13',
    'pfr;': '\uD835\uDD2D',
    'Phi;': '\u03A6',
    'phi;': '\u03C6',
    'phiv;': '\u03D5',
    'phmmat;': '\u2133',
    'phone;': '\u260E',
    'Pi;': '\u03A0',
    'pi;': '\u03C0',
    'pitchfork;': '\u22D4',
    'piv;': '\u03D6',
    'planck;': '\u210F',
    'planckh;': '\u210E',
    'plankv;': '\u210F',
    'plus;': '\u002B',
    'plusacir;': '\u2A23',
    'plusb;': '\u229E',
    'pluscir;': '\u2A22',
    'plusdo;': '\u2214',
    'plusdu;': '\u2A25',
    'pluse;': '\u2A72',
    'PlusMinus;': '\u00B1',
    'plusmn;': '\u00B1',
    'plusmn': '\u00B1',
    'plussim;': '\u2A26',
    'plustwo;': '\u2A27',
    'pm;': '\u00B1',
    'Poincareplane;': '\u210C',
    'pointint;': '\u2A15',
    'Popf;': '\u2119',
    'popf;': '\uD835\uDD61',
    'pound;': '\u00A3',
    'pound': '\u00A3',
    'Pr;': '\u2ABB',
    'pr;': '\u227A',
    'prap;': '\u2AB7',
    'prcue;': '\u227C',
    'prE;': '\u2AB3',
    'pre;': '\u2AAF',
    'prec;': '\u227A',
    'precapprox;': '\u2AB7',
    'preccurlyeq;': '\u227C',
    'Precedes;': '\u227A',
    'PrecedesEqual;': '\u2AAF',
    'PrecedesSlantEqual;': '\u227C',
    'PrecedesTilde;': '\u227E',
    'preceq;': '\u2AAF',
    'precnapprox;': '\u2AB9',
    'precneqq;': '\u2AB5',
    'precnsim;': '\u22E8',
    'precsim;': '\u227E',
    'Prime;': '\u2033',
    'prime;': '\u2032',
    'primes;': '\u2119',
    'prnap;': '\u2AB9',
    'prnE;': '\u2AB5',
    'prnsim;': '\u22E8',
    'prod;': '\u220F',
    'Product;': '\u220F',
    'profalar;': '\u232E',
    'profline;': '\u2312',
    'profsurf;': '\u2313',
    'prop;': '\u221D',
    'Proportion;': '\u2237',
    'Proportional;': '\u221D',
    'propto;': '\u221D',
    'prsim;': '\u227E',
    'prurel;': '\u22B0',
    'Pscr;': '\uD835\uDCAB',
    'pscr;': '\uD835\uDCC5',
    'Psi;': '\u03A8',
    'psi;': '\u03C8',
    'puncsp;': '\u2008',
    'Qfr;': '\uD835\uDD14',
    'qfr;': '\uD835\uDD2E',
    'qint;': '\u2A0C',
    'Qopf;': '\u211A',
    'qopf;': '\uD835\uDD62',
    'qprime;': '\u2057',
    'Qscr;': '\uD835\uDCAC',
    'qscr;': '\uD835\uDCC6',
    'quaternions;': '\u210D',
    'quatint;': '\u2A16',
    'quest;': '\u003F',
    'questeq;': '\u225F',
    'QUOT;': '\u0022',
    'QUOT': '\u0022',
    'quot;': '\u0022',
    'quot': '\u0022',
    'rAarr;': '\u21DB',
    'race;': '\u223D\u0331',
    'Racute;': '\u0154',
    'racute;': '\u0155',
    'radic;': '\u221A',
    'raemptyv;': '\u29B3',
    'Rang;': '\u27EB',
    'rang;': '\u27E9',
    'rangd;': '\u2992',
    'range;': '\u29A5',
    'rangle;': '\u27E9',
    'raquo;': '\u00BB',
    'raquo': '\u00BB',
    'Rarr;': '\u21A0',
    'rArr;': '\u21D2',
    'rarr;': '\u2192',
    'rarrap;': '\u2975',
    'rarrb;': '\u21E5',
    'rarrbfs;': '\u2920',
    'rarrc;': '\u2933',
    'rarrfs;': '\u291E',
    'rarrhk;': '\u21AA',
    'rarrlp;': '\u21AC',
    'rarrpl;': '\u2945',
    'rarrsim;': '\u2974',
    'Rarrtl;': '\u2916',
    'rarrtl;': '\u21A3',
    'rarrw;': '\u219D',
    'rAtail;': '\u291C',
    'ratail;': '\u291A',
    'ratio;': '\u2236',
    'rationals;': '\u211A',
    'RBarr;': '\u2910',
    'rBarr;': '\u290F',
    'rbarr;': '\u290D',
    'rbbrk;': '\u2773',
    'rbrace;': '\u007D',
    'rbrack;': '\u005D',
    'rbrke;': '\u298C',
    'rbrksld;': '\u298E',
    'rbrkslu;': '\u2990',
    'Rcaron;': '\u0158',
    'rcaron;': '\u0159',
    'Rcedil;': '\u0156',
    'rcedil;': '\u0157',
    'rceil;': '\u2309',
    'rcub;': '\u007D',
    'Rcy;': '\u0420',
    'rcy;': '\u0440',
    'rdca;': '\u2937',
    'rdldhar;': '\u2969',
    'rdquo;': '\u201D',
    'rdquor;': '\u201D',
    'rdsh;': '\u21B3',
    'Re;': '\u211C',
    'real;': '\u211C',
    'realine;': '\u211B',
    'realpart;': '\u211C',
    'reals;': '\u211D',
    'rect;': '\u25AD',
    'REG;': '\u00AE',
    'REG': '\u00AE',
    'reg;': '\u00AE',
    'reg': '\u00AE',
    'ReverseElement;': '\u220B',
    'ReverseEquilibrium;': '\u21CB',
    'ReverseUpEquilibrium;': '\u296F',
    'rfisht;': '\u297D',
    'rfloor;': '\u230B',
    'Rfr;': '\u211C',
    'rfr;': '\uD835\uDD2F',
    'rHar;': '\u2964',
    'rhard;': '\u21C1',
    'rharu;': '\u21C0',
    'rharul;': '\u296C',
    'Rho;': '\u03A1',
    'rho;': '\u03C1',
    'rhov;': '\u03F1',
    'RightAngleBracket;': '\u27E9',
    'RightArrow;': '\u2192',
    'Rightarrow;': '\u21D2',
    'rightarrow;': '\u2192',
    'RightArrowBar;': '\u21E5',
    'RightArrowLeftArrow;': '\u21C4',
    'rightarrowtail;': '\u21A3',
    'RightCeiling;': '\u2309',
    'RightDoubleBracket;': '\u27E7',
    'RightDownTeeVector;': '\u295D',
    'RightDownVector;': '\u21C2',
    'RightDownVectorBar;': '\u2955',
    'RightFloor;': '\u230B',
    'rightharpoondown;': '\u21C1',
    'rightharpoonup;': '\u21C0',
    'rightleftarrows;': '\u21C4',
    'rightleftharpoons;': '\u21CC',
    'rightrightarrows;': '\u21C9',
    'rightsquigarrow;': '\u219D',
    'RightTee;': '\u22A2',
    'RightTeeArrow;': '\u21A6',
    'RightTeeVector;': '\u295B',
    'rightthreetimes;': '\u22CC',
    'RightTriangle;': '\u22B3',
    'RightTriangleBar;': '\u29D0',
    'RightTriangleEqual;': '\u22B5',
    'RightUpDownVector;': '\u294F',
    'RightUpTeeVector;': '\u295C',
    'RightUpVector;': '\u21BE',
    'RightUpVectorBar;': '\u2954',
    'RightVector;': '\u21C0',
    'RightVectorBar;': '\u2953',
    'ring;': '\u02DA',
    'risingdotseq;': '\u2253',
    'rlarr;': '\u21C4',
    'rlhar;': '\u21CC',
    'rlm;': '\u200F',
    'rmoust;': '\u23B1',
    'rmoustache;': '\u23B1',
    'rnmid;': '\u2AEE',
    'roang;': '\u27ED',
    'roarr;': '\u21FE',
    'robrk;': '\u27E7',
    'ropar;': '\u2986',
    'Ropf;': '\u211D',
    'ropf;': '\uD835\uDD63',
    'roplus;': '\u2A2E',
    'rotimes;': '\u2A35',
    'RoundImplies;': '\u2970',
    'rpar;': '\u0029',
    'rpargt;': '\u2994',
    'rppolint;': '\u2A12',
    'rrarr;': '\u21C9',
    'Rrightarrow;': '\u21DB',
    'rsaquo;': '\u203A',
    'Rscr;': '\u211B',
    'rscr;': '\uD835\uDCC7',
    'Rsh;': '\u21B1',
    'rsh;': '\u21B1',
    'rsqb;': '\u005D',
    'rsquo;': '\u2019',
    'rsquor;': '\u2019',
    'rthree;': '\u22CC',
    'rtimes;': '\u22CA',
    'rtri;': '\u25B9',
    'rtrie;': '\u22B5',
    'rtrif;': '\u25B8',
    'rtriltri;': '\u29CE',
    'RuleDelayed;': '\u29F4',
    'ruluhar;': '\u2968',
    'rx;': '\u211E',
    'Sacute;': '\u015A',
    'sacute;': '\u015B',
    'sbquo;': '\u201A',
    'Sc;': '\u2ABC',
    'sc;': '\u227B',
    'scap;': '\u2AB8',
    'Scaron;': '\u0160',
    'scaron;': '\u0161',
    'sccue;': '\u227D',
    'scE;': '\u2AB4',
    'sce;': '\u2AB0',
    'Scedil;': '\u015E',
    'scedil;': '\u015F',
    'Scirc;': '\u015C',
    'scirc;': '\u015D',
    'scnap;': '\u2ABA',
    'scnE;': '\u2AB6',
    'scnsim;': '\u22E9',
    'scpolint;': '\u2A13',
    'scsim;': '\u227F',
    'Scy;': '\u0421',
    'scy;': '\u0441',
    'sdot;': '\u22C5',
    'sdotb;': '\u22A1',
    'sdote;': '\u2A66',
    'searhk;': '\u2925',
    'seArr;': '\u21D8',
    'searr;': '\u2198',
    'searrow;': '\u2198',
    'sect;': '\u00A7',
    'sect': '\u00A7',
    'semi;': '\u003B',
    'seswar;': '\u2929',
    'setminus;': '\u2216',
    'setmn;': '\u2216',
    'sext;': '\u2736',
    'Sfr;': '\uD835\uDD16',
    'sfr;': '\uD835\uDD30',
    'sfrown;': '\u2322',
    'sharp;': '\u266F',
    'SHCHcy;': '\u0429',
    'shchcy;': '\u0449',
    'SHcy;': '\u0428',
    'shcy;': '\u0448',
    'ShortDownArrow;': '\u2193',
    'ShortLeftArrow;': '\u2190',
    'shortmid;': '\u2223',
    'shortparallel;': '\u2225',
    'ShortRightArrow;': '\u2192',
    'ShortUpArrow;': '\u2191',
    'shy;': '\u00AD',
    'shy': '\u00AD',
    'Sigma;': '\u03A3',
    'sigma;': '\u03C3',
    'sigmaf;': '\u03C2',
    'sigmav;': '\u03C2',
    'sim;': '\u223C',
    'simdot;': '\u2A6A',
    'sime;': '\u2243',
    'simeq;': '\u2243',
    'simg;': '\u2A9E',
    'simgE;': '\u2AA0',
    'siml;': '\u2A9D',
    'simlE;': '\u2A9F',
    'simne;': '\u2246',
    'simplus;': '\u2A24',
    'simrarr;': '\u2972',
    'slarr;': '\u2190',
    'SmallCircle;': '\u2218',
    'smallsetminus;': '\u2216',
    'smashp;': '\u2A33',
    'smeparsl;': '\u29E4',
    'smid;': '\u2223',
    'smile;': '\u2323',
    'smt;': '\u2AAA',
    'smte;': '\u2AAC',
    'smtes;': '\u2AAC\uFE00',
    'SOFTcy;': '\u042C',
    'softcy;': '\u044C',
    'sol;': '\u002F',
    'solb;': '\u29C4',
    'solbar;': '\u233F',
    'Sopf;': '\uD835\uDD4A',
    'sopf;': '\uD835\uDD64',
    'spades;': '\u2660',
    'spadesuit;': '\u2660',
    'spar;': '\u2225',
    'sqcap;': '\u2293',
    'sqcaps;': '\u2293\uFE00',
    'sqcup;': '\u2294',
    'sqcups;': '\u2294\uFE00',
    'Sqrt;': '\u221A',
    'sqsub;': '\u228F',
    'sqsube;': '\u2291',
    'sqsubset;': '\u228F',
    'sqsubseteq;': '\u2291',
    'sqsup;': '\u2290',
    'sqsupe;': '\u2292',
    'sqsupset;': '\u2290',
    'sqsupseteq;': '\u2292',
    'squ;': '\u25A1',
    'Square;': '\u25A1',
    'square;': '\u25A1',
    'SquareIntersection;': '\u2293',
    'SquareSubset;': '\u228F',
    'SquareSubsetEqual;': '\u2291',
    'SquareSuperset;': '\u2290',
    'SquareSupersetEqual;': '\u2292',
    'SquareUnion;': '\u2294',
    'squarf;': '\u25AA',
    'squf;': '\u25AA',
    'srarr;': '\u2192',
    'Sscr;': '\uD835\uDCAE',
    'sscr;': '\uD835\uDCC8',
    'ssetmn;': '\u2216',
    'ssmile;': '\u2323',
    'sstarf;': '\u22C6',
    'Star;': '\u22C6',
    'star;': '\u2606',
    'starf;': '\u2605',
    'straightepsilon;': '\u03F5',
    'straightphi;': '\u03D5',
    'strns;': '\u00AF',
    'Sub;': '\u22D0',
    'sub;': '\u2282',
    'subdot;': '\u2ABD',
    'subE;': '\u2AC5',
    'sube;': '\u2286',
    'subedot;': '\u2AC3',
    'submult;': '\u2AC1',
    'subnE;': '\u2ACB',
    'subne;': '\u228A',
    'subplus;': '\u2ABF',
    'subrarr;': '\u2979',
    'Subset;': '\u22D0',
    'subset;': '\u2282',
    'subseteq;': '\u2286',
    'subseteqq;': '\u2AC5',
    'SubsetEqual;': '\u2286',
    'subsetneq;': '\u228A',
    'subsetneqq;': '\u2ACB',
    'subsim;': '\u2AC7',
    'subsub;': '\u2AD5',
    'subsup;': '\u2AD3',
    'succ;': '\u227B',
    'succapprox;': '\u2AB8',
    'succcurlyeq;': '\u227D',
    'Succeeds;': '\u227B',
    'SucceedsEqual;': '\u2AB0',
    'SucceedsSlantEqual;': '\u227D',
    'SucceedsTilde;': '\u227F',
    'succeq;': '\u2AB0',
    'succnapprox;': '\u2ABA',
    'succneqq;': '\u2AB6',
    'succnsim;': '\u22E9',
    'succsim;': '\u227F',
    'SuchThat;': '\u220B',
    'Sum;': '\u2211',
    'sum;': '\u2211',
    'sung;': '\u266A',
    'Sup;': '\u22D1',
    'sup;': '\u2283',
    'sup1;': '\u00B9',
    'sup1': '\u00B9',
    'sup2;': '\u00B2',
    'sup2': '\u00B2',
    'sup3;': '\u00B3',
    'sup3': '\u00B3',
    'supdot;': '\u2ABE',
    'supdsub;': '\u2AD8',
    'supE;': '\u2AC6',
    'supe;': '\u2287',
    'supedot;': '\u2AC4',
    'Superset;': '\u2283',
    'SupersetEqual;': '\u2287',
    'suphsol;': '\u27C9',
    'suphsub;': '\u2AD7',
    'suplarr;': '\u297B',
    'supmult;': '\u2AC2',
    'supnE;': '\u2ACC',
    'supne;': '\u228B',
    'supplus;': '\u2AC0',
    'Supset;': '\u22D1',
    'supset;': '\u2283',
    'supseteq;': '\u2287',
    'supseteqq;': '\u2AC6',
    'supsetneq;': '\u228B',
    'supsetneqq;': '\u2ACC',
    'supsim;': '\u2AC8',
    'supsub;': '\u2AD4',
    'supsup;': '\u2AD6',
    'swarhk;': '\u2926',
    'swArr;': '\u21D9',
    'swarr;': '\u2199',
    'swarrow;': '\u2199',
    'swnwar;': '\u292A',
    'szlig;': '\u00DF',
    'szlig': '\u00DF',
    'Tab;': '\u0009',
    'target;': '\u2316',
    'Tau;': '\u03A4',
    'tau;': '\u03C4',
    'tbrk;': '\u23B4',
    'Tcaron;': '\u0164',
    'tcaron;': '\u0165',
    'Tcedil;': '\u0162',
    'tcedil;': '\u0163',
    'Tcy;': '\u0422',
    'tcy;': '\u0442',
    'tdot;': '\u20DB',
    'telrec;': '\u2315',
    'Tfr;': '\uD835\uDD17',
    'tfr;': '\uD835\uDD31',
    'there4;': '\u2234',
    'Therefore;': '\u2234',
    'therefore;': '\u2234',
    'Theta;': '\u0398',
    'theta;': '\u03B8',
    'thetasym;': '\u03D1',
    'thetav;': '\u03D1',
    'thickapprox;': '\u2248',
    'thicksim;': '\u223C',
    'ThickSpace;': '\u205F\u200A',
    'thinsp;': '\u2009',
    'ThinSpace;': '\u2009',
    'thkap;': '\u2248',
    'thksim;': '\u223C',
    'THORN;': '\u00DE',
    'THORN': '\u00DE',
    'thorn;': '\u00FE',
    'thorn': '\u00FE',
    'Tilde;': '\u223C',
    'tilde;': '\u02DC',
    'TildeEqual;': '\u2243',
    'TildeFullEqual;': '\u2245',
    'TildeTilde;': '\u2248',
    'times;': '\u00D7',
    'times': '\u00D7',
    'timesb;': '\u22A0',
    'timesbar;': '\u2A31',
    'timesd;': '\u2A30',
    'tint;': '\u222D',
    'toea;': '\u2928',
    'top;': '\u22A4',
    'topbot;': '\u2336',
    'topcir;': '\u2AF1',
    'Topf;': '\uD835\uDD4B',
    'topf;': '\uD835\uDD65',
    'topfork;': '\u2ADA',
    'tosa;': '\u2929',
    'tprime;': '\u2034',
    'TRADE;': '\u2122',
    'trade;': '\u2122',
    'triangle;': '\u25B5',
    'triangledown;': '\u25BF',
    'triangleleft;': '\u25C3',
    'trianglelefteq;': '\u22B4',
    'triangleq;': '\u225C',
    'triangleright;': '\u25B9',
    'trianglerighteq;': '\u22B5',
    'tridot;': '\u25EC',
    'trie;': '\u225C',
    'triminus;': '\u2A3A',
    'TripleDot;': '\u20DB',
    'triplus;': '\u2A39',
    'trisb;': '\u29CD',
    'tritime;': '\u2A3B',
    'trpezium;': '\u23E2',
    'Tscr;': '\uD835\uDCAF',
    'tscr;': '\uD835\uDCC9',
    'TScy;': '\u0426',
    'tscy;': '\u0446',
    'TSHcy;': '\u040B',
    'tshcy;': '\u045B',
    'Tstrok;': '\u0166',
    'tstrok;': '\u0167',
    'twixt;': '\u226C',
    'twoheadleftarrow;': '\u219E',
    'twoheadrightarrow;': '\u21A0',
    'Uacute;': '\u00DA',
    'Uacute': '\u00DA',
    'uacute;': '\u00FA',
    'uacute': '\u00FA',
    'Uarr;': '\u219F',
    'uArr;': '\u21D1',
    'uarr;': '\u2191',
    'Uarrocir;': '\u2949',
    'Ubrcy;': '\u040E',
    'ubrcy;': '\u045E',
    'Ubreve;': '\u016C',
    'ubreve;': '\u016D',
    'Ucirc;': '\u00DB',
    'Ucirc': '\u00DB',
    'ucirc;': '\u00FB',
    'ucirc': '\u00FB',
    'Ucy;': '\u0423',
    'ucy;': '\u0443',
    'udarr;': '\u21C5',
    'Udblac;': '\u0170',
    'udblac;': '\u0171',
    'udhar;': '\u296E',
    'ufisht;': '\u297E',
    'Ufr;': '\uD835\uDD18',
    'ufr;': '\uD835\uDD32',
    'Ugrave;': '\u00D9',
    'Ugrave': '\u00D9',
    'ugrave;': '\u00F9',
    'ugrave': '\u00F9',
    'uHar;': '\u2963',
    'uharl;': '\u21BF',
    'uharr;': '\u21BE',
    'uhblk;': '\u2580',
    'ulcorn;': '\u231C',
    'ulcorner;': '\u231C',
    'ulcrop;': '\u230F',
    'ultri;': '\u25F8',
    'Umacr;': '\u016A',
    'umacr;': '\u016B',
    'uml;': '\u00A8',
    'uml': '\u00A8',
    'UnderBar;': '\u005F',
    'UnderBrace;': '\u23DF',
    'UnderBracket;': '\u23B5',
    'UnderParenthesis;': '\u23DD',
    'Union;': '\u22C3',
    'UnionPlus;': '\u228E',
    'Uogon;': '\u0172',
    'uogon;': '\u0173',
    'Uopf;': '\uD835\uDD4C',
    'uopf;': '\uD835\uDD66',
    'UpArrow;': '\u2191',
    'Uparrow;': '\u21D1',
    'uparrow;': '\u2191',
    'UpArrowBar;': '\u2912',
    'UpArrowDownArrow;': '\u21C5',
    'UpDownArrow;': '\u2195',
    'Updownarrow;': '\u21D5',
    'updownarrow;': '\u2195',
    'UpEquilibrium;': '\u296E',
    'upharpoonleft;': '\u21BF',
    'upharpoonright;': '\u21BE',
    'uplus;': '\u228E',
    'UpperLeftArrow;': '\u2196',
    'UpperRightArrow;': '\u2197',
    'Upsi;': '\u03D2',
    'upsi;': '\u03C5',
    'upsih;': '\u03D2',
    'Upsilon;': '\u03A5',
    'upsilon;': '\u03C5',
    'UpTee;': '\u22A5',
    'UpTeeArrow;': '\u21A5',
    'upuparrows;': '\u21C8',
    'urcorn;': '\u231D',
    'urcorner;': '\u231D',
    'urcrop;': '\u230E',
    'Uring;': '\u016E',
    'uring;': '\u016F',
    'urtri;': '\u25F9',
    'Uscr;': '\uD835\uDCB0',
    'uscr;': '\uD835\uDCCA',
    'utdot;': '\u22F0',
    'Utilde;': '\u0168',
    'utilde;': '\u0169',
    'utri;': '\u25B5',
    'utrif;': '\u25B4',
    'uuarr;': '\u21C8',
    'Uuml;': '\u00DC',
    'Uuml': '\u00DC',
    'uuml;': '\u00FC',
    'uuml': '\u00FC',
    'uwangle;': '\u29A7',
    'vangrt;': '\u299C',
    'varepsilon;': '\u03F5',
    'varkappa;': '\u03F0',
    'varnothing;': '\u2205',
    'varphi;': '\u03D5',
    'varpi;': '\u03D6',
    'varpropto;': '\u221D',
    'vArr;': '\u21D5',
    'varr;': '\u2195',
    'varrho;': '\u03F1',
    'varsigma;': '\u03C2',
    'varsubsetneq;': '\u228A\uFE00',
    'varsubsetneqq;': '\u2ACB\uFE00',
    'varsupsetneq;': '\u228B\uFE00',
    'varsupsetneqq;': '\u2ACC\uFE00',
    'vartheta;': '\u03D1',
    'vartriangleleft;': '\u22B2',
    'vartriangleright;': '\u22B3',
    'Vbar;': '\u2AEB',
    'vBar;': '\u2AE8',
    'vBarv;': '\u2AE9',
    'Vcy;': '\u0412',
    'vcy;': '\u0432',
    'VDash;': '\u22AB',
    'Vdash;': '\u22A9',
    'vDash;': '\u22A8',
    'vdash;': '\u22A2',
    'Vdashl;': '\u2AE6',
    'Vee;': '\u22C1',
    'vee;': '\u2228',
    'veebar;': '\u22BB',
    'veeeq;': '\u225A',
    'vellip;': '\u22EE',
    'Verbar;': '\u2016',
    'verbar;': '\u007C',
    'Vert;': '\u2016',
    'vert;': '\u007C',
    'VerticalBar;': '\u2223',
    'VerticalLine;': '\u007C',
    'VerticalSeparator;': '\u2758',
    'VerticalTilde;': '\u2240',
    'VeryThinSpace;': '\u200A',
    'Vfr;': '\uD835\uDD19',
    'vfr;': '\uD835\uDD33',
    'vltri;': '\u22B2',
    'vnsub;': '\u2282\u20D2',
    'vnsup;': '\u2283\u20D2',
    'Vopf;': '\uD835\uDD4D',
    'vopf;': '\uD835\uDD67',
    'vprop;': '\u221D',
    'vrtri;': '\u22B3',
    'Vscr;': '\uD835\uDCB1',
    'vscr;': '\uD835\uDCCB',
    'vsubnE;': '\u2ACB\uFE00',
    'vsubne;': '\u228A\uFE00',
    'vsupnE;': '\u2ACC\uFE00',
    'vsupne;': '\u228B\uFE00',
    'Vvdash;': '\u22AA',
    'vzigzag;': '\u299A',
    'Wcirc;': '\u0174',
    'wcirc;': '\u0175',
    'wedbar;': '\u2A5F',
    'Wedge;': '\u22C0',
    'wedge;': '\u2227',
    'wedgeq;': '\u2259',
    'weierp;': '\u2118',
    'Wfr;': '\uD835\uDD1A',
    'wfr;': '\uD835\uDD34',
    'Wopf;': '\uD835\uDD4E',
    'wopf;': '\uD835\uDD68',
    'wp;': '\u2118',
    'wr;': '\u2240',
    'wreath;': '\u2240',
    'Wscr;': '\uD835\uDCB2',
    'wscr;': '\uD835\uDCCC',
    'xcap;': '\u22C2',
    'xcirc;': '\u25EF',
    'xcup;': '\u22C3',
    'xdtri;': '\u25BD',
    'Xfr;': '\uD835\uDD1B',
    'xfr;': '\uD835\uDD35',
    'xhArr;': '\u27FA',
    'xharr;': '\u27F7',
    'Xi;': '\u039E',
    'xi;': '\u03BE',
    'xlArr;': '\u27F8',
    'xlarr;': '\u27F5',
    'xmap;': '\u27FC',
    'xnis;': '\u22FB',
    'xodot;': '\u2A00',
    'Xopf;': '\uD835\uDD4F',
    'xopf;': '\uD835\uDD69',
    'xoplus;': '\u2A01',
    'xotime;': '\u2A02',
    'xrArr;': '\u27F9',
    'xrarr;': '\u27F6',
    'Xscr;': '\uD835\uDCB3',
    'xscr;': '\uD835\uDCCD',
    'xsqcup;': '\u2A06',
    'xuplus;': '\u2A04',
    'xutri;': '\u25B3',
    'xvee;': '\u22C1',
    'xwedge;': '\u22C0',
    'Yacute;': '\u00DD',
    'Yacute': '\u00DD',
    'yacute;': '\u00FD',
    'yacute': '\u00FD',
    'YAcy;': '\u042F',
    'yacy;': '\u044F',
    'Ycirc;': '\u0176',
    'ycirc;': '\u0177',
    'Ycy;': '\u042B',
    'ycy;': '\u044B',
    'yen;': '\u00A5',
    'yen': '\u00A5',
    'Yfr;': '\uD835\uDD1C',
    'yfr;': '\uD835\uDD36',
    'YIcy;': '\u0407',
    'yicy;': '\u0457',
    'Yopf;': '\uD835\uDD50',
    'yopf;': '\uD835\uDD6A',
    'Yscr;': '\uD835\uDCB4',
    'yscr;': '\uD835\uDCCE',
    'YUcy;': '\u042E',
    'yucy;': '\u044E',
    'Yuml;': '\u0178',
    'yuml;': '\u00FF',
    'yuml': '\u00FF',
    'Zacute;': '\u0179',
    'zacute;': '\u017A',
    'Zcaron;': '\u017D',
    'zcaron;': '\u017E',
    'Zcy;': '\u0417',
    'zcy;': '\u0437',
    'Zdot;': '\u017B',
    'zdot;': '\u017C',
    'zeetrf;': '\u2128',
    'ZeroWidthSpace;': '\u200B',
    'Zeta;': '\u0396',
    'zeta;': '\u03B6',
    'Zfr;': '\u2128',
    'zfr;': '\uD835\uDD37',
    'ZHcy;': '\u0416',
    'zhcy;': '\u0436',
    'zigrarr;': '\u21DD',
    'Zopf;': '\u2124',
    'zopf;': '\uD835\uDD6B',
    'Zscr;': '\uD835\uDCB5',
    'zscr;': '\uD835\uDCCF',
    'zwj;': '\u200D',
    'zwnj;': '\u200C'
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/

Object.defineProperty(exports, "__esModule", { value: true });
const wxmlScanner_1 = __webpack_require__(41);
const wxmlLanguageTypes_1 = __webpack_require__(42);
const wxmlTags_1 = __webpack_require__(44);
const path = __webpack_require__(15);
const fs = __webpack_require__(36);
const BASE_DIR = path.resolve(__dirname, '../..');
function doHover(document, position, wxmlDocument) {
    let offset = document.offsetAt(position);
    let node = wxmlDocument.findNodeAt(offset);
    if (!node || !node.tag)
        return null;
    let provider = wxmlTags_1.getWXMLTagProvider();
    let attr = node.getAttributeAtOffset(offset);
    function getTagHover(tag, range) {
        tag = tag.toLowerCase();
        let hover = null;
        provider.collectTags((t, _label) => {
            if (t === tag) {
                let file = path.join(BASE_DIR, `gen/${tag}.md`);
                if (fs.existsSync(file)) {
                    let content = fs.readFileSync(file, 'utf8');
                    hover = {
                        contents: {
                            kind: 'markdown',
                            value: content
                        },
                        range,
                    };
                }
            }
        });
        return hover || null;
    }
    function getTagNameRange(tokenType, startOffset) {
        let scanner = wxmlScanner_1.createScanner(document.getText(), startOffset);
        let token = scanner.scan();
        while (token !== wxmlLanguageTypes_1.TokenType.EOS &&
            (scanner.getTokenEnd() < offset ||
                (scanner.getTokenEnd() === offset && token !== tokenType))) {
            token = scanner.scan();
        }
        if (token === tokenType && offset <= scanner.getTokenEnd()) {
            return {
                start: document.positionAt(scanner.getTokenOffset()),
                end: document.positionAt(scanner.getTokenEnd()),
            };
        }
        return null;
    }
    if (attr) {
        let parts = attr.split('|');
        let file = path.join(BASE_DIR, `gen/${node.tag}/${parts[0]}.md`);
        let exists = fs.existsSync(file);
        if (exists) {
            let content = fs.readFileSync(file, 'utf8');
            let start = parseInt(parts[1], 10);
            let range = {
                start: document.positionAt(start),
                end: document.positionAt(start + parts[0].length),
            };
            return {
                contents: {
                    kind: 'markdown',
                    value: content
                },
                range,
            };
        }
        else {
            // show tag hover
            let start = parseInt(parts[1], 10);
            return getTagHover(node.tag, {
                start: document.positionAt(start),
                end: document.positionAt(start + parts[0].length)
            });
        }
    }
    if (node.endTagStart && offset >= node.endTagStart) {
        let tagRange = getTagNameRange(wxmlLanguageTypes_1.TokenType.EndTag, node.endTagStart);
        if (tagRange) {
            return getTagHover(node.tag, tagRange);
        }
        return null;
    }
    let tagRange = getTagNameRange(wxmlLanguageTypes_1.TokenType.StartTag, node.start);
    if (tagRange) {
        return getTagHover(node.tag, tagRange);
    }
    return null;
}
exports.default = doHover;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vscode_jsonrpc_1 = __webpack_require__(6);
const vscode_languageserver_1 = __webpack_require__(4);
const net = __webpack_require__(18);
const stream = __webpack_require__(51);
function connectionFromOptions(options) {
    let reader;
    let writer;
    switch (options.method) {
        case 'socket':
            // For socket connection, the message connection needs to be
            // established before the server socket starts listening.
            // Do that, and return at the end of this block.
            writer = new stream.PassThrough();
            reader = new stream.PassThrough();
            let server = net
                .createServer(socket => {
                server.close();
                socket.pipe(reader);
                writer.pipe(socket);
            })
                .listen(options.port);
            break;
        case 'node-ipc':
            reader = new vscode_jsonrpc_1.IPCMessageReader(process);
            writer = new vscode_jsonrpc_1.IPCMessageWriter(process);
            break;
        case 'stdio':
        default:
            reader = process.stdin;
            writer = process.stdout;
            break;
    }
    return vscode_languageserver_1.createConnection(reader, writer);
}
exports.default = connectionFromOptions;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ })
/******/ ])));